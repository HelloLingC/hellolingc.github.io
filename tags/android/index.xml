<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Android on MoonLab</title><link>https://moonlab.top/tags/android/</link><description>Recent content in Android on MoonLab</description><generator>Hugo -- 0.143.1</generator><language>zh-CN</language><lastBuildDate>Mon, 24 Feb 2020 11:52:38 +0000</lastBuildDate><atom:link href="https://moonlab.top/tags/android/index.xml" rel="self" type="application/rss+xml"/><item><title>坑：Litepal save方法返回true却没有保存</title><link>https://moonlab.top/posts/2020/pit-for-litepal-save/</link><pubDate>Mon, 24 Feb 2020 11:52:38 +0000</pubDate><guid>https://moonlab.top/posts/2020/pit-for-litepal-save/</guid><description>&lt;p>在开发 Madoka 日记时，做到导出导入的功能时，我想偷个懒导出直接用 Gson 将 Java 对象转换为 json 然后放在 txt 中，导入的时候再将 json 转为 javaBean 就行啦。&lt;/p>
&lt;p>而数据库我用的是 Litepal 直接搞，使用这个库的好处就是速度快，方便，适合新手。&lt;/p>
&lt;p>但其实 sqlite 的语法和一些其他的语句并不难，所以用这个库就是为了方便&amp;hellip;&lt;/p>
&lt;p>使用 Litepal 储存数据时，需要调用 save() 方法。&lt;/p>
&lt;p>这里我就遇到了一个问题，明明 save() 方法返回的是 true ，但数据库里没有需要保存的数据啊？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> Gson gson &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Gson();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Diary diary &lt;span style="color:#f92672">=&lt;/span> gson.&lt;span style="color:#a6e22e">fromJson&lt;/span>(json, Diary.&lt;span style="color:#a6e22e">class&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> diary.&lt;span style="color:#a6e22e">save&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是调用 Gson 将 json 转换为 javabean 对象。&lt;/p>
&lt;p>明明 Diary 的内容全是正确的，我开始询问度娘。&lt;/p>
&lt;p>结果没找到跟我的问题直接相关的文章，结果我看到了有个人在吐槽啥 setting getting，我就想到了会不会是因为没有调用 Diary 的构造方法？&lt;/p>
&lt;p>Diary 作为一个 Litepal 的，它是继承自 LitePalSupport 的，会不会是因为没有调用 LitePalSupport 的构造方法呢？&lt;/p>
&lt;p>我将导入代码改了一下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span> Gson gson &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Gson();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Diary diary &lt;span style="color:#f92672">=&lt;/span> gson.&lt;span style="color:#a6e22e">fromJson&lt;/span>(json, Diary.&lt;span style="color:#a6e22e">class&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Diary saveDiary &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Diary();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> saveDiary.&lt;span style="color:#a6e22e">setId&lt;/span>(diary.&lt;span style="color:#a6e22e">getId&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> saveDiary.&lt;span style="color:#a6e22e">setCreatedTime&lt;/span>(diary.&lt;span style="color:#a6e22e">getCreatedTime&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> saveDiary.&lt;span style="color:#a6e22e">setLastUpdatedTime&lt;/span>(diary.&lt;span style="color:#a6e22e">getLastUpdatedTime&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ... 省略一万个代码
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> saveDiary.&lt;span style="color:#a6e22e">save&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>果然，最后正常了&amp;hellip;&lt;/p></description></item><item><title>Android Shizuku源码分析 第二篇</title><link>https://moonlab.top/posts/2020/android-shizuku-theory2/</link><pubDate>Tue, 04 Feb 2020 11:43:10 +0000</pubDate><guid>https://moonlab.top/posts/2020/android-shizuku-theory2/</guid><description>本文深入分析了 Shizuku 的启动过程，特别是 &lt;code>Starter&lt;/code> 类的 &lt;code>main&lt;/code> 方法是如何被调用的。文章首先回顾了 Shizuku 的基本概念，并介绍了通过 &lt;code>adb&lt;/code> 命令激活 ShizukuService 的过程，重点分析了 &lt;code>start.sh&lt;/code> 脚本的执行。当用户通过 ShizukuManager 启动应用时，&lt;code>start.sh&lt;/code> 脚本被调用，该脚本负责设置环境并执行 &lt;code>libshizuku.so&lt;/code> 文件。文章详细描述了 &lt;code>ShizukuManager&lt;/code> 在启动时如何写入 &lt;code>start.sh&lt;/code> 文件及其相关的 dex 文件路径。接着，文章探讨了 &lt;code>libshizuku.so&lt;/code> 中的 &lt;code>main&lt;/code> 方法，说明了如何通过 &lt;code>app_process&lt;/code> 启动 Java 类 &lt;code>moe.shizuku.server.Starter&lt;/code>。在 &lt;code>Starter&lt;/code> 类的 &lt;code>main&lt;/code> 方法中，创建了 &lt;code>ShizukuService&lt;/code> 实例，从而完成了 ShizukuService 的启动。最后，作者总结了整个过程，强调了用户通过简单的 &lt;code>adb&lt;/code> 命令如何触发一系列复杂的操作，最终实现 Shizuku 的功能。</description></item><item><title>Android Shizuku源码分析</title><link>https://moonlab.top/posts/2020/android-shizuku-theory/</link><pubDate>Sun, 02 Feb 2020 19:24:10 +0000</pubDate><guid>https://moonlab.top/posts/2020/android-shizuku-theory/</guid><description>本文分析了 Shizuku 的源码，介绍了其如何通过 Binder 实现与 Android 系统服务的交互。Shizuku 应用引导用户以 root 或 adb 方式运行服务进程，利用 ShizukuBinderWrapper 进行系统隐藏 API 的调用。文章详细探讨了 ShizukuBinderWrapper 的构造、transact 方法及其与 IShizukuService 的通信过程，最后简要提及 ShizukuService 的启动流程。作者计划进一步深入分析 Shizuku 的启动机制。</description></item><item><title>Android 监听第三方Activity的一举一动</title><link>https://moonlab.top/posts/2020/android-activity-monitor/</link><pubDate>Sat, 01 Feb 2020 18:39:25 +0000</pubDate><guid>https://moonlab.top/posts/2020/android-activity-monitor/</guid><description>这篇文章主要记录了作者在2019年初的个人感受和一些技术探索。作者回顾了过去一年的经历，感到没有太多进展，并提到冬季的天气和国内的传染病情况。尽管在家中待得久了，作者也提到了一些娱乐活动，比如观看动画和春晚，但整体上对新番的期待逐渐减弱。在技术方面，作者分享了在Android开发中监听Activity启动的需求，探讨了几种方法来获取Activity的类名。首先，作者提到使用&lt;code>ActivityManager&lt;/code>的&lt;code>getRunningTasks&lt;/code>方法，但由于权限限制，这种方法不可行。接着，作者提到&lt;code>UsageStatsManager&lt;/code>只能获取应用包名，而无法获取Activity类名。最终，作者发现了&lt;code>IActivityController&lt;/code>接口，并通过使用Shizuku工具来调用系统API，从而实现了监听Activity启动的功能。总结来说，文章结合了个人生活感受与技术探索，展示了作者在面对生活和技术挑战时的思考与解决方案。</description></item><item><title>Android笔记#1 View的事件分发机制解析</title><link>https://moonlab.top/posts/2019/android-view-motionevent/</link><pubDate>Wed, 14 Aug 2019 11:07:50 +0000</pubDate><guid>https://moonlab.top/posts/2019/android-view-motionevent/</guid><description>本文总结了《Android艺术开发探索》中关于View事件分发机制的内容。事件序列从ACTION_DOWN开始，经过多个ACTION_MOVE，最后以ACTION_UP结束。事件传递顺序为Activity -&amp;gt; Window -&amp;gt; DecorView -&amp;gt; RootView。事件分发主要通过dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent三个方法实现。ViewGroup的onInterceptTouchEvent默认返回false，子View可通过OnTouchListener处理事件。总结指出，事件分发机制确保一个事件序列只能被一个View拦截和消耗，且OnTouchListener优先级高于onTouchEvent。</description></item><item><title>知乎日报的问题</title><link>https://moonlab.top/posts/2019/android-zhihu-daily/</link><pubDate>Thu, 04 Jul 2019 20:34:10 +0000</pubDate><guid>https://moonlab.top/posts/2019/android-zhihu-daily/</guid><description>作者在暑假期间开始开发一个第三方的知乎日报客户端，使用MVP架构。遇到了一些问题，如全局异常处理和JSON解析，选择使用Picasso加载图片。为了解决WebView中图片宽度过大的问题，作者通过JavaScript调整图片大小。最终，作者完成了基本的加载和查看功能，并在GitHub上分享了代码。尽管开发过程充满挑战，作者仍然享受这个过程。</description></item></channel></rss>