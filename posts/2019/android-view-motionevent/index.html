<!doctype html><html lang=cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Android笔记#1 View的事件分发机制解析 | MoonLab</title>
<meta name=keywords content="Android"><meta name=description content="本文总结了《Android艺术开发探索》中关于View事件分发机制的内容。事件序列从ACTION_DOWN开始，经过多个ACTION_MOVE，最后以ACTION_UP结束。事件传递顺序为Activity -> Window -> DecorView -> RootView。事件分发主要通过dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent三个方法实现。ViewGroup的onInterceptTouchEvent默认返回false，子View可通过OnTouchListener处理事件。总结指出，事件分发机制确保一个事件序列只能被一个View拦截和消耗，且OnTouchListener优先级高于onTouchEvent。"><meta name=author content="LingC"><link rel=canonical href=https://moonlab.top/posts/2019/android-view-motionevent/><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"],["$","$"]]},loader:{load:["ui/safe"]}}</script><link crossorigin=anonymous href=/assets/css/stylesheet.1ff5a7b3bb4a96bf1747dfa25e8031167d4537d7ae4b78fac2b752886047a06e.css rel="preload stylesheet" as=style><link rel=icon href=/moon.svg type=image/svg+xml><link rel=icon type=image/png sizes=16x16 href=https://moonlab.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://moonlab.top/favicon-32x32.png><link rel=apple-touch-icon href=https://moonlab.top/apple-touch-icon.png><link rel=mask-icon href=https://moonlab.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=cn href=https://moonlab.top/posts/2019/android-view-motionevent/><link rel=alternate hreflang=en href=https://moonlab.top/en/posts/2019/android-view-motionevent/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Android笔记#1 View的事件分发机制解析"><meta property="og:description" content="本文总结了《Android艺术开发探索》中关于View事件分发机制的内容。事件序列从ACTION_DOWN开始，经过多个ACTION_MOVE，最后以ACTION_UP结束。事件传递顺序为Activity -> Window -> DecorView -> RootView。事件分发主要通过dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent三个方法实现。ViewGroup的onInterceptTouchEvent默认返回false，子View可通过OnTouchListener处理事件。总结指出，事件分发机制确保一个事件序列只能被一个View拦截和消耗，且OnTouchListener优先级高于onTouchEvent。"><meta property="og:type" content="article"><meta property="og:url" content="https://moonlab.top/posts/2019/android-view-motionevent/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-08-14T11:07:50+00:00"><meta property="article:modified_time" content="2019-08-14T11:07:50+00:00"><meta property="og:site_name" content="MoonLab"><meta name=twitter:card content="summary"><meta name=twitter:title content="Android笔记#1 View的事件分发机制解析"><meta name=twitter:description content="本文总结了《Android艺术开发探索》中关于View事件分发机制的内容。事件序列从ACTION_DOWN开始，经过多个ACTION_MOVE，最后以ACTION_UP结束。事件传递顺序为Activity -> Window -> DecorView -> RootView。事件分发主要通过dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent三个方法实现。ViewGroup的onInterceptTouchEvent默认返回false，子View可通过OnTouchListener处理事件。总结指出，事件分发机制确保一个事件序列只能被一个View拦截和消耗，且OnTouchListener优先级高于onTouchEvent。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://moonlab.top/posts/"},{"@type":"ListItem","position":2,"name":"Android笔记#1 View的事件分发机制解析","item":"https://moonlab.top/posts/2019/android-view-motionevent/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Android笔记#1 View的事件分发机制解析","name":"Android笔记#1 View的事件分发机制解析","description":"本文总结了《Android艺术开发探索》中关于View事件分发机制的内容。事件序列从ACTION_DOWN开始，经过多个ACTION_MOVE，最后以ACTION_UP结束。事件传递顺序为Activity -\u0026gt; Window -\u0026gt; DecorView -\u0026gt; RootView。事件分发主要通过dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent三个方法实现。ViewGroup的onInterceptTouchEvent默认返回false，子View可通过OnTouchListener处理事件。总结指出，事件分发机制确保一个事件序列只能被一个View拦截和消耗，且OnTouchListener优先级高于onTouchEvent。","keywords":["Android"],"articleBody":"咕咕咕 基本上本文是把《Android艺术开发探索》这本书中的 View 事件分发机制 这一章节总结一下。\n很久以前的 Android 开发笔记太鸡儿水了。\n简单介绍 众所周知，一个事件序列是由 MotionEvent.ACTION_DOWN（按下） 开始，多个 MotionEvent.MOVE（移动） 和一个 MotionEvent.ACTION_UP（抬起） 结束。\n一个事件的传递顺序：Activity - \u003e Window -\u003e DecorView - \u003e RootView (你所设置的 View)\nViewGroup 是继承自 View 的，这点也是基础中的基础了。\n事件的分发过程主要由以下三个方法来完成：\npublic boolean dispatchTouchEvent(MotionEvent ev); // 如果事件传到此 View 那么该方法一定会被调用 public boolean onInterceptTouchEvent(MotionEvent event); // 用来判断 View 是否拦截此事件，如果拦截那么在这事件序列中此方法不会再被调用 public boolean onTouchEvent(MotionEvent event); // 用来处理事件，返回是否消耗当前事件，如果不消耗那么在同一事件序列不会再让此 View 接收到。 下面我们附上一段伪代码来阐述三个方法的关系：\npublic boolean dispatchTouchEvent(MotionEvent ev) { boolean consume = false; // onInterceptTouchEvent判断是否拦截此事件 if (onInterceptTouchEvent(ev)) { // 拦截的话，则调用 onTouchEvent 处理事件，返回是否消耗此事件 consume = onTouchEvent(ev); } else { // 不拦截交给子类 View consume = child.dispatchTouchEvent(ev); } // 此方法的返回值为是否拦截此事件。 return consume; } 注意调用 dispatchTouchEvent 时往往第一个是 ACTION_DOWN 事件，请搞清“拦截”和“消耗”两个概念，onInterceptTouchEvent 返回的是是否拦截，onTouchEvent 返回的是是否消耗。\n如果 onInterceptTouchEvent 返回 true ，但 onTouchEvent 返回 false，即代表拦截但不消耗事件，如果这个事件是 ACTION_DOWN，那么同一事件序列的其他事件将不会再交给此 View 了，这时会调用上一级的 onTouchEvent，如果还是 false ，那么就调用上一级的上一级的 onTouchEvent，如果都是 false，那么最终会交给 Activity 处理。\nonTouchEvent 的返回值是取决于 View 的 clickable 和 longClickable 属性的，只要其中一个为 true，那么 onTouchEvent 就会返回 true，与 enable 属性无关。\n如果 View 不消耗除 ACTION_DOWN 以外的事件，那么父 View 的 onTouchEvent 不会被调用，并且此 View 仍然可以接收到事件，不消耗的事件将直接交给 Activity 处理。\nAndroid 源码中 ViewGroup 的 onInterceptTouchEvent 默认会返回 false，而 View 则没有这个方法，会直接调用 onTouchEvent。\n如果一个 View 设置了 OnTouchListener 那么里面的 onTouch 方法则会被回调，我们都知道 onTouch 会返回一个 boolean ，onTouchEvent 方法是否被调用是取决于这个 boolean 的，如果返回 false，那么 onTouchEvent 则会被调用，我们经常设置的 OnClickListener 是在 onTouchEvent 中的。\n从上面可以看出， onTouchListener 的优先级高于 onTouchEvent，而 OnClickListener 则是优先级最低的。\n在网上翻到了一张图，总结得挺好：https://upload-images.jianshu.io/upload_images/2435754-a09ab44cb25be80d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/972/format/webp\nAndroid 源码分析 事件最开始会调用到 Activity 的 dispatchTouchEvent 方法：\npublic boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); } if (getWindow().superDispatchTouchEvent(ev)) { return true; } return onTouchEvent(ev); } 事件开始交给 Activity 所属的 Window 进行分发，Window 的实现类是 PhoneWindow ，我们继续来看 PhoneWindow#superDispatchTouchEvent：\nprivate DecorView mDecor; @Override public boolean superDispatchTouchEvent(MotionEvent event) { return mDecor.superDispatchTouchEvent(event); } 很明显，Window 又把事件交给了 DecorView ，就是你所设置的布局的父 View。\nDecorView#superDispatchTouchEvent\npublic boolean superDispatchTouchEvent(MotionEvent event) { // 这里又将事件传到了 ViewGroup, DecorView 是继承自 ViewGroup 的 return super.dispatchTouchEvent(event); } 我们所设置的 View 称作为根 View 或 顶级 View。\n至此，事件已经传递到我们的 View 中了。\nViewGroup 源码解析 我们来看看 ViewGroup 中的 dispatchTouchEvent 方法的一小段，因为 Android 源码实在过于复杂，我们只需要专注我们需要专注的内容就好。\n// 这个地方是 ViewGroup 是否拦截事件的一个逻辑 final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { // 当 ViewGroup 满足 actionMasked == MotionEvent.ACTION_DOWN 或 mFirstTouchTarget != null 且没有设置标记位就会调用onInterceptTouchEvent // FLAG_DISALLOW_INTERCEPT 标记位是由 requestDisallowInterceptTouchEvent 方法设置的 final boolean disallowIntercept = (mGroupFlags \u0026 FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { // onInterceptTouchEvent 方法在这 intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { intercepted = false; } } else { // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; } 这个 actionMasked == MotionEvent.ACTION_DOWN 不用多说，如果事件由 ViewGroup 拦截的话，那么后面的 mFirstTouchTarget != null 中的 mFirstTouchTarget 是指向子元素的，一旦事件由 ViewGroup 拦截，那么后面的 ACTION_MOVE, ACTION_UP 经过这里时， (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) 会返回 false，所以 ViewGroup 的 onInterceptTouchEvent 不会再被调用，且同一事件序列的其他事件都交由它处理。\n如果 ViewGroup 不拦截，那么 mFirstTouchTarget 会指向子元素，mFirstTouchTarget != null 为 true，则会调用 onInterceptTouchEvent ，显而易见不是吗？\n我们可以仔细想想，第一个传递到这里的事件经常是 ACTION_DOWN，如果拦截那么后续的同一事件序列中的其他事件都会交给它处理，这时候 onInterceptTouchEvent 被调用。\n假如后面又来了个 ACTION_MOVE，这时候因为 (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) 为 false 会直接拦截，但不会调用 onInterceptTouchEvent 了。\n这就证明了：如果一个 View 一旦决定拦截，那么将不再调用 onInterceptTouchEvent 来询问是否拦截。\n你们可以看到一个名为 FLAG_DISALLOW_INTERCEPT 的标记位，如果子 View 设置了这个标记位，那么\n(!disallowIntercept) 表达式则为 false，父 View 则不会拦截此事件，当然 ACTION_DOWN 事件除外，因为 View 判断如果是 ACTION_DOWN 则会重置这个标记位。\n标记位重置代码：\n// Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) { // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); } 我们再看 ViewGroup 不拦截的时候：\nfinal int childrenCount = mChildrenCount; if (newTouchTarget == null \u0026\u0026 childrenCount != 0) { final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); final ArrayList\u003cView\u003e preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null \u0026\u0026 isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i \u003e= 0; i--) { final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); // child final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); if (childWithAccessibilityFocus != null) { if (childWithAccessibilityFocus != child) { continue; } childWithAccessibilityFocus = null; i = childrenCount - 1; } if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { newTouchTarget.pointerIdBits |= idBitsToAssign; break; } resetCancelNextUpFlag(child); // dispatchTransformedTouchEvent 则是调用子元素的 dispatchTouchEvent if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) { // childIndex points into presorted list, find original index for (int j = 0; j \u003c childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; } ev.setTargetAccessibilityFocus(false); } if (preorderedList != null) preorderedList.clear(); } 简单说一吧，dispatchTransformedTouchEvent 则是调用子元素的 dispatchTouchEvent，同来向子View 分发事件，我们来看 dispatchTransformedTouchEvent 方法内容：\nfinal int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) { event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) { // 因为 ViewGroup extends View ，所以会调用 View 的 dispatchTouchEvent 方法 handled = super.dispatchTouchEvent(event); } else { // 调用子类的 dispatchTouchEvent handled = child.dispatchTouchEvent(event); } event.setAction(oldAction); // 返回子 View 是否拦截 return handled; } 如果 dispatchTransformedTouchEvent 为 true，那么会调用 addTouchTarget 方法为 mFirstTouchTarget 赋值\nnewTouchTarget = addTouchTarget(child, idBitsToAssign); // 具体 addTouchTarget 里的代码就不看了 alreadyDispatchedToNewTouchTarget = true; 如果最后遍历所有子元素事件却没有被合适的处理，要么是 ViewGroup 内没有合适的可传递 View，要么是子 View 拦截并处理了事件，但 onTouchEvent 返回了 false，所以 dispatchTouchEvent 也返回了 false。\n这时 ViewGroup 就要自己处理事件了（震惊！孤寡老人竟无子可用！这究竟是…）：\n// Dispatch to touch targets. if (mFirstTouchTarget == null) { // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS) } 调用了 dispatchTransformedTouchEven 并在参数 child 传入了 null，回顾我们上面贴出来的 dispatchTransformedTouchEven 方法的代码，我们可以看到如果为 child == null则会调用 ViewGroup 自己的 dispatchTouchEvent。\nViewGroup 的源码解析到此也差不多了。\nView 源码解析 接着看它的一段 dispatchTouchEvent 代码：\npublic boolean dispatchTouchEvent(MotionEvent event) { boolean result = false; ... if (onFilterTouchEventForSecurity(event)) { if ((mViewFlags \u0026 ENABLED_MASK) == ENABLED \u0026\u0026 handleScrollBarDragging(event)) { result = true; } ListenerInfo li = mListenerInfo; if (li != null \u0026\u0026 li.mOnTouchListener != null \u0026\u0026 (mViewFlags \u0026 ENABLED_MASK) == ENABLED \u0026\u0026 li.mOnTouchListener.onTouch(this, event)) { result = true; } if (!result \u0026\u0026 onTouchEvent(event)) { result = true; } } ... return result; } 这里的 View 只处理自己的事件，不会再向下传递事件了。\n我们看向中间第二个 if ，我们可以看到如果设置了 OnTouchListener，且 onTouch 方法返回了 true，那么 onTouchEvent 就不会执行，证明了前面所说的 OnTouchListener 优先级高于 OnClickListener。\n我们再看 onTouchEvent 的代码：\nif ((viewFlags \u0026 ENABLED_MASK) == DISABLED) { if (action == MotionEvent.ACTION_UP \u0026\u0026 (mPrivateFlags \u0026 PFLAG_PRESSED) != 0) { setPressed(false); } return (((viewFlags \u0026 CLICKABLE) == CLICKABLE || (viewFlags \u0026 LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags \u0026 CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE); } 即使 View 为 disabled 状态也能消耗事件。\nif (((viewFlags \u0026 CLICKABLE) == CLICKABLE || (viewFlags \u0026 LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags \u0026 CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) { // 只要 clickable | longClickable 其中一个为 true 就能执行这里，onTouchEvent 就会返回 true switch (action) { case MotionEvent.ACTION_UP: // 当手指抬起时 boolean prepressed = (mPrivateFlags \u0026 PFLAG_PREPRESSED) != 0; if ((mPrivateFlags \u0026 PFLAG_PRESSED) != 0 || prepressed) { ... if (!mHasPerformedLongPress \u0026\u0026 !mIgnoreNextUpEvent) { removeLongPressCallback(); if (!focusTaken) { if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { // performClick 将会调用 onClick performClick(); } } } ... } break; ... } ... return true; } 我们接着看 performClick 方法\npublic boolean performClick() { final boolean result; final ListenerInfo li = mListenerInfo; if (li != null \u0026\u0026 li.mOnClickListener != null) { // 点击音 playSoundEffect(SoundEffectConstants.CLICK); // onClick 在这 li.mOnClickListener.onClick(this); result = true; } else { result = false; } sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); return result; } 还没结束，我们再看一看 setOnClickListener 方法\npublic void setOnClickListener(OnClickListener l) { if (!isClickable) { setClickable(true); } getListenerInfo.mOnClickListener = l; } 可以看到在设置 View 的 OnClickListener会自动改变 View 的 clickable 属性，而 setOnLongClickListener 也是一样的。\n总结 事件分发机制就是点击事件的分发，在手指接触屏幕后产生的同一个事件序列都是点击事件。 点击事件的传递顺序是由外向内。 正常情况下一个事件序列只能被一个 View 拦截且消耗。 如果 View 决定拦截事件，那么这一个事件序列都会由这个View来处理。 当子 View 拦截却不不消耗点击事件，那点击事件将交由给他的父View去处理，如果所有的 View 都没有消耗掉点击事件（onTouchEvent 返回 false），最终 Activity 会调用自己的 onTouchEvent。 onInterceptTouchEvent 方法不一定会每次都执行，一个 View 一旦决定拦截将不会调用 onInterceptTouchEvent OnTouchListener的优先级高于onTouchEvent()。这样做的好处是方便在外部处理事件。 当我们把 View 设置为不可用状态，View 依然会消耗事件。 ","wordCount":"1163","inLanguage":"cn","datePublished":"2019-08-14T11:07:50Z","dateModified":"2019-08-14T11:07:50Z","author":{"@type":"Person","name":"LingC"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://moonlab.top/posts/2019/android-view-motionevent/"},"publisher":{"@type":"Organization","name":"MoonLab","logo":{"@type":"ImageObject","url":"https://moonlab.top/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://moonlab.top/ accesskey=h title="MoonLab (Alt + H)"><img src=/moon.svg alt aria-label=logo height=20>MoonLab</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://moonlab.top/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://moonlab.top/archives/ title=归档><span>归档</span></a></li><li><a href=https://moonlab.top/search/ title=搜索><span>搜索</span></a></li><li><a href=https://moonlab.top/about/ title=关于><span>关于</span></a></li><li><a href=https://www.travellings.cn/go.html target=_blank title=开往><span>开往</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><div class=body-layout><div class=leftbar></div><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Android笔记#1 View的事件分发机制解析</h1><div class=post-meta><span title='2019-08-14 11:07:50 +0000 UTC'>August 14, 2019</span>&nbsp;·&nbsp;LingC&nbsp;|&nbsp;用其他语言阅读文章:<ul class=i18n_list><li><a href=https://moonlab.top/en/posts/2019/android-view-motionevent/>English🇺🇸</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%92%95%e5%92%95%e5%92%95 aria-label=咕咕咕>咕咕咕</a></li><li><a href=#%e7%ae%80%e5%8d%95%e4%bb%8b%e7%bb%8d aria-label=简单介绍>简单介绍</a></li><li><a href=#android-%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90 aria-label="Android 源码分析">Android 源码分析</a><ul><li><a href=#viewgroup-%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90 aria-label="ViewGroup 源码解析">ViewGroup 源码解析</a></li><li><a href=#view-%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90 aria-label="View 源码解析">View 源码解析</a></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></div></details></div><div class=post-summary><span class=bold-text>📦 由AI生成的摘要</span><br><span class=post-summary-main>本文总结了《Android艺术开发探索》中关于View事件分发机制的内容。事件序列从ACTION_DOWN开始，经过多个ACTION_MOVE，最后以ACTION_UP结束。事件传递顺序为Activity -> Window -> DecorView -> RootView。事件分发主要通过dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent三个方法实现。ViewGroup的onInterceptTouchEvent默认返回false，子View可通过OnTouchListener处理事件。总结指出，事件分发机制确保一个事件序列只能被一个View拦截和消耗，且OnTouchListener优先级高于onTouchEvent。</span></div><div class=post-content><h1 id=咕咕咕>咕咕咕<a hidden class=anchor aria-hidden=true href=#咕咕咕>#</a></h1><p>基本上本文是把《Android艺术开发探索》这本书中的 View 事件分发机制 这一章节总结一下。</p><p>很久以前的 Android 开发笔记太鸡儿水了。</p><h1 id=简单介绍>简单介绍<a hidden class=anchor aria-hidden=true href=#简单介绍>#</a></h1><p>众所周知，一个事件序列是由 MotionEvent.ACTION_DOWN（按下） 开始，多个 MotionEvent.MOVE（移动） 和一个 MotionEvent.ACTION_UP（抬起） 结束。</p><p>一个事件的传递顺序：Activity - > Window -> DecorView - > RootView (你所设置的 View)</p><p>ViewGroup 是继承自 View 的，这点也是基础中的基础了。</p><p>事件的分发过程主要由以下三个方法来完成：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>dispatchTouchEvent</span>(MotionEvent ev);
</span></span><span style=display:flex><span><span style=color:#75715e>// 如果事件传到此 View 那么该方法一定会被调用</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>onInterceptTouchEvent</span>(MotionEvent event);
</span></span><span style=display:flex><span><span style=color:#75715e>// 用来判断 View 是否拦截此事件，如果拦截那么在这事件序列中此方法不会再被调用</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>onTouchEvent</span>(MotionEvent event);
</span></span><span style=display:flex><span><span style=color:#75715e>// 用来处理事件，返回是否消耗当前事件，如果不消耗那么在同一事件序列不会再让此 View 接收到。</span>
</span></span></code></pre></div><p>下面我们附上一段伪代码来阐述三个方法的关系：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>dispatchTouchEvent</span>(MotionEvent ev) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span> consume <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// onInterceptTouchEvent判断是否拦截此事件</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (onInterceptTouchEvent(ev)) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 拦截的话，则调用 onTouchEvent 处理事件，返回是否消耗此事件</span>
</span></span><span style=display:flex><span>        consume <span style=color:#f92672>=</span> onTouchEvent(ev);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 不拦截交给子类 View</span>
</span></span><span style=display:flex><span>        consume <span style=color:#f92672>=</span> child.<span style=color:#a6e22e>dispatchTouchEvent</span>(ev);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 此方法的返回值为是否拦截此事件。</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> consume;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注意调用 dispatchTouchEvent 时往往第一个是 ACTION_DOWN 事件，请搞清“拦截”和“消耗”两个概念，onInterceptTouchEvent 返回的是是否拦截，onTouchEvent 返回的是是否消耗。</p><p>如果 onInterceptTouchEvent 返回 true ，但 onTouchEvent 返回 false，即代表拦截但不消耗事件，如果这个事件是 ACTION_DOWN，那么同一事件序列的其他事件将不会再交给此 View 了，这时会调用上一级的 onTouchEvent，如果还是 false ，那么就调用上一级的上一级的 onTouchEvent，如果都是 false，那么最终会交给 Activity 处理。</p><p>onTouchEvent 的返回值是取决于 View 的 clickable 和 longClickable 属性的，只要其中一个为 true，那么 onTouchEvent 就会返回 true，与 enable 属性无关。</p><p>如果 View 不消耗除 ACTION_DOWN 以外的事件，那么父 View 的 onTouchEvent 不会被调用，并且此 View 仍然可以接收到事件，不消耗的事件将直接交给 Activity 处理。</p><p>Android 源码中 ViewGroup 的 onInterceptTouchEvent 默认会返回 false，而 View 则没有这个方法，会直接调用 onTouchEvent。</p><p>如果一个 View 设置了 OnTouchListener 那么里面的 onTouch 方法则会被回调，我们都知道 onTouch 会返回一个 boolean ，onTouchEvent 方法是否被调用是取决于这个 boolean 的，如果返回 false，那么 onTouchEvent 则会被调用，我们经常设置的 OnClickListener 是在 onTouchEvent 中的。</p><p>从上面可以看出， onTouchListener 的优先级高于 onTouchEvent，而 OnClickListener 则是优先级最低的。</p><p>在网上翻到了一张图，总结得挺好：https://upload-images.jianshu.io/upload_images/2435754-a09ab44cb25be80d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/972/format/webp</p><h1 id=android-源码分析>Android 源码分析<a hidden class=anchor aria-hidden=true href=#android-源码分析>#</a></h1><p>事件最开始会调用到 Activity 的 dispatchTouchEvent 方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>dispatchTouchEvent</span>(MotionEvent ev) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (ev.<span style=color:#a6e22e>getAction</span>() <span style=color:#f92672>==</span> MotionEvent.<span style=color:#a6e22e>ACTION_DOWN</span>) {
</span></span><span style=display:flex><span>            onUserInteraction();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (getWindow().<span style=color:#a6e22e>superDispatchTouchEvent</span>(ev)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> onTouchEvent(ev);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>事件开始交给 Activity 所属的 Window 进行分发，Window 的实现类是 PhoneWindow ，我们继续来看 PhoneWindow#superDispatchTouchEvent：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> DecorView mDecor;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>superDispatchTouchEvent</span>(MotionEvent event) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> mDecor.<span style=color:#a6e22e>superDispatchTouchEvent</span>(event);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>很明显，Window 又把事件交给了 DecorView ，就是你所设置的布局的父 View。</p><p>DecorView#superDispatchTouchEvent</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>superDispatchTouchEvent</span>(MotionEvent event) {
</span></span><span style=display:flex><span>     <span style=color:#75715e>// 这里又将事件传到了 ViewGroup, DecorView 是继承自 ViewGroup 的</span>
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>dispatchTouchEvent</span>(event);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们所设置的 View 称作为根 View 或 顶级 View。</p><p>至此，事件已经传递到我们的 View 中了。</p><h2 id=viewgroup-源码解析>ViewGroup 源码解析<a hidden class=anchor aria-hidden=true href=#viewgroup-源码解析>#</a></h2><p>我们来看看 ViewGroup 中的 dispatchTouchEvent 方法的一小段，因为 Android 源码实在过于复杂，我们只需要专注我们需要专注的内容就好。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 这个地方是 ViewGroup 是否拦截事件的一个逻辑</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> intercepted;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (actionMasked <span style=color:#f92672>==</span> MotionEvent.<span style=color:#a6e22e>ACTION_DOWN</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>||</span> mFirstTouchTarget <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>   <span style=color:#75715e>// 当 ViewGroup 满足 actionMasked == MotionEvent.ACTION_DOWN 或 mFirstTouchTarget != null 且没有设置标记位就会调用onInterceptTouchEvent</span>
</span></span><span style=display:flex><span>   <span style=color:#75715e>// FLAG_DISALLOW_INTERCEPT 标记位是由 requestDisallowInterceptTouchEvent 方法设置的</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> disallowIntercept <span style=color:#f92672>=</span> (mGroupFlags <span style=color:#f92672>&amp;</span> FLAG_DISALLOW_INTERCEPT) <span style=color:#f92672>!=</span> 0;
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>disallowIntercept) {
</span></span><span style=display:flex><span>     <span style=color:#75715e>// onInterceptTouchEvent 方法在这</span>
</span></span><span style=display:flex><span>     intercepted <span style=color:#f92672>=</span> onInterceptTouchEvent(ev);
</span></span><span style=display:flex><span>     ev.<span style=color:#a6e22e>setAction</span>(action); <span style=color:#75715e>// restore action in case it was changed</span>
</span></span><span style=display:flex><span>   } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>     intercepted <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// There are no touch targets and this action is not an initial down</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// so this view group continues to intercept touches.</span>
</span></span><span style=display:flex><span>    intercepted <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个 actionMasked == MotionEvent.ACTION_DOWN 不用多说，如果事件由 ViewGroup 拦截的话，那么后面的 mFirstTouchTarget != null 中的 mFirstTouchTarget 是指向子元素的，一旦事件由 ViewGroup 拦截，那么后面的 ACTION_MOVE, ACTION_UP 经过这里时， (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) 会返回 false，所以 ViewGroup 的 onInterceptTouchEvent 不会再被调用，且同一事件序列的其他事件都交由它处理。</p><p>如果 ViewGroup 不拦截，那么 mFirstTouchTarget 会指向子元素，mFirstTouchTarget != null 为 true，则会调用 onInterceptTouchEvent ，显而易见不是吗？</p><p>我们可以仔细想想，第一个传递到这里的事件经常是 ACTION_DOWN，如果拦截那么后续的同一事件序列中的其他事件都会交给它处理，这时候 onInterceptTouchEvent 被调用。</p><p>假如后面又来了个 ACTION_MOVE，这时候因为 (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) 为 false 会直接拦截，但不会调用 onInterceptTouchEvent 了。</p><p>这就证明了：如果一个 View 一旦决定拦截，那么将不再调用 onInterceptTouchEvent 来询问是否拦截。</p><p>你们可以看到一个名为 FLAG_DISALLOW_INTERCEPT 的标记位，如果子 View 设置了这个标记位，那么</p><p>(!disallowIntercept) 表达式则为 false，父 View 则不会拦截此事件，当然 ACTION_DOWN 事件除外，因为 View 判断如果是 ACTION_DOWN 则会重置这个标记位。</p><p>标记位重置代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Handle an initial down.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (actionMasked <span style=color:#f92672>==</span> MotionEvent.<span style=color:#a6e22e>ACTION_DOWN</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Throw away all previous state when starting a new touch gesture.</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// The framework may have dropped the up or cancel event for the previous gesture</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// due to an app switch, ANR, or some other state change.</span>
</span></span><span style=display:flex><span>   cancelAndClearTouchTargets(ev);
</span></span><span style=display:flex><span>   resetTouchState();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们再看 ViewGroup 不拦截的时候：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> childrenCount <span style=color:#f92672>=</span> mChildrenCount;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (newTouchTarget <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> childrenCount <span style=color:#f92672>!=</span> 0) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>float</span> x <span style=color:#f92672>=</span> ev.<span style=color:#a6e22e>getX</span>(actionIndex);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>float</span> y <span style=color:#f92672>=</span> ev.<span style=color:#a6e22e>getY</span>(actionIndex);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> ArrayList<span style=color:#f92672>&lt;</span>View<span style=color:#f92672>&gt;</span> preorderedList <span style=color:#f92672>=</span> buildTouchDispatchChildList();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> customOrder <span style=color:#f92672>=</span> preorderedList <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;&amp;</span> isChildrenDrawingOrderEnabled();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> View<span style=color:#f92672>[]</span> children <span style=color:#f92672>=</span> mChildren;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> childrenCount <span style=color:#f92672>-</span> 1; i <span style=color:#f92672>&gt;=</span> 0; i<span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> childIndex <span style=color:#f92672>=</span> getAndVerifyPreorderedIndex(
</span></span><span style=display:flex><span>                childrenCount, i, customOrder);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// child </span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> View child <span style=color:#f92672>=</span> getAndVerifyPreorderedView(
</span></span><span style=display:flex><span>                preorderedList, children, childIndex);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (childWithAccessibilityFocus <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (childWithAccessibilityFocus <span style=color:#f92672>!=</span> child) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            childWithAccessibilityFocus <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            i <span style=color:#f92672>=</span> childrenCount <span style=color:#f92672>-</span> 1;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>canViewReceivePointerEvents(child)
</span></span><span style=display:flex><span>                <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>isTransformedTouchPointInView(x, y, child, <span style=color:#66d9ef>null</span>)) {
</span></span><span style=display:flex><span>            ev.<span style=color:#a6e22e>setTargetAccessibilityFocus</span>(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        newTouchTarget <span style=color:#f92672>=</span> getTouchTarget(child);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (newTouchTarget <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            newTouchTarget.<span style=color:#a6e22e>pointerIdBits</span> <span style=color:#f92672>|=</span> idBitsToAssign;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        resetCancelNextUpFlag(child);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// dispatchTransformedTouchEvent 则是调用子元素的 dispatchTouchEvent</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (dispatchTransformedTouchEvent(ev, <span style=color:#66d9ef>false</span>, child, idBitsToAssign)) {
</span></span><span style=display:flex><span>            mLastTouchDownTime <span style=color:#f92672>=</span> ev.<span style=color:#a6e22e>getDownTime</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (preorderedList <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// childIndex points into presorted list, find original index</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> 0; j <span style=color:#f92672>&lt;</span> childrenCount; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (children<span style=color:#f92672>[</span>childIndex<span style=color:#f92672>]</span> <span style=color:#f92672>==</span> mChildren<span style=color:#f92672>[</span>j<span style=color:#f92672>]</span>) {
</span></span><span style=display:flex><span>                        mLastTouchDownIndex <span style=color:#f92672>=</span> j;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                mLastTouchDownIndex <span style=color:#f92672>=</span> childIndex;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            mLastTouchDownX <span style=color:#f92672>=</span> ev.<span style=color:#a6e22e>getX</span>();
</span></span><span style=display:flex><span>            mLastTouchDownY <span style=color:#f92672>=</span> ev.<span style=color:#a6e22e>getY</span>();
</span></span><span style=display:flex><span>            newTouchTarget <span style=color:#f92672>=</span> addTouchTarget(child, idBitsToAssign);
</span></span><span style=display:flex><span>            alreadyDispatchedToNewTouchTarget <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        ev.<span style=color:#a6e22e>setTargetAccessibilityFocus</span>(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (preorderedList <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) preorderedList.<span style=color:#a6e22e>clear</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>简单说一吧，dispatchTransformedTouchEvent 则是调用子元素的 dispatchTouchEvent，同来向子View 分发事件，我们来看 dispatchTransformedTouchEvent 方法内容：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> oldAction <span style=color:#f92672>=</span> event.<span style=color:#a6e22e>getAction</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (cancel <span style=color:#f92672>||</span> oldAction <span style=color:#f92672>==</span> MotionEvent.<span style=color:#a6e22e>ACTION_CANCEL</span>) {
</span></span><span style=display:flex><span>    event.<span style=color:#a6e22e>setAction</span>(MotionEvent.<span style=color:#a6e22e>ACTION_CANCEL</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (child <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 因为 ViewGroup extends View ，所以会调用 View 的 dispatchTouchEvent 方法</span>
</span></span><span style=display:flex><span>        handled <span style=color:#f92672>=</span> <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>dispatchTouchEvent</span>(event);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 调用子类的 dispatchTouchEvent</span>
</span></span><span style=display:flex><span>        handled <span style=color:#f92672>=</span> child.<span style=color:#a6e22e>dispatchTouchEvent</span>(event);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    event.<span style=color:#a6e22e>setAction</span>(oldAction);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 返回子 View 是否拦截</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> handled;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果 dispatchTransformedTouchEvent 为 true，那么会调用 addTouchTarget 方法为 mFirstTouchTarget 赋值</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>newTouchTarget <span style=color:#f92672>=</span> addTouchTarget(child, idBitsToAssign);
</span></span><span style=display:flex><span><span style=color:#75715e>// 具体 addTouchTarget 里的代码就不看了</span>
</span></span><span style=display:flex><span>alreadyDispatchedToNewTouchTarget <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span></code></pre></div><p>如果最后遍历所有子元素事件却没有被合适的处理，要么是 ViewGroup 内没有合适的可传递 View，要么是子 View 拦截并处理了事件，但 onTouchEvent 返回了 false，所以 dispatchTouchEvent 也返回了 false。</p><p>这时 ViewGroup 就要自己处理事件了（震惊！孤寡老人竟无子可用！这究竟是&mldr;）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Dispatch to touch targets.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (mFirstTouchTarget <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// No touch targets so treat this as an ordinary view.</span>
</span></span><span style=display:flex><span>    handled <span style=color:#f92672>=</span> dispatchTransformedTouchEvent(ev, canceled, <span style=color:#66d9ef>null</span>, TouchTarget.<span style=color:#a6e22e>ALL_POINTER_IDS</span>)   
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>调用了 dispatchTransformedTouchEven 并在参数 child 传入了 null，回顾我们上面贴出来的 dispatchTransformedTouchEven 方法的代码，我们可以看到如果为 child == null则会调用 ViewGroup 自己的 dispatchTouchEvent。</p><p>ViewGroup 的源码解析到此也差不多了。</p><h2 id=view-源码解析>View 源码解析<a hidden class=anchor aria-hidden=true href=#view-源码解析>#</a></h2><p>接着看它的一段 dispatchTouchEvent 代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>dispatchTouchEvent</span>(MotionEvent event) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span> result <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (onFilterTouchEventForSecurity(event)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ((mViewFlags <span style=color:#f92672>&amp;</span> ENABLED_MASK) <span style=color:#f92672>==</span> ENABLED <span style=color:#f92672>&amp;&amp;</span> handleScrollBarDragging(event)) {
</span></span><span style=display:flex><span>            result <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        ListenerInfo li <span style=color:#f92672>=</span> mListenerInfo;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (li <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> li.<span style=color:#a6e22e>mOnTouchListener</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;&amp;</span> (mViewFlags <span style=color:#f92672>&amp;</span> ENABLED_MASK) <span style=color:#f92672>==</span> ENABLED
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;&amp;</span> li.<span style=color:#a6e22e>mOnTouchListener</span>.<span style=color:#a6e22e>onTouch</span>(<span style=color:#66d9ef>this</span>, event)) {
</span></span><span style=display:flex><span>            result <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>result <span style=color:#f92672>&amp;&amp;</span> onTouchEvent(event)) {
</span></span><span style=display:flex><span>            result <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里的 View 只处理自己的事件，不会再向下传递事件了。</p><p>我们看向中间第二个 if ，我们可以看到如果设置了 OnTouchListener，且 onTouch 方法返回了 true，那么 onTouchEvent 就不会执行，证明了前面所说的 OnTouchListener 优先级高于 OnClickListener。</p><p>我们再看 onTouchEvent 的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>if</span> ((viewFlags <span style=color:#f92672>&amp;</span> ENABLED_MASK) <span style=color:#f92672>==</span> DISABLED) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (action <span style=color:#f92672>==</span> MotionEvent.<span style=color:#a6e22e>ACTION_UP</span> <span style=color:#f92672>&amp;&amp;</span> (mPrivateFlags <span style=color:#f92672>&amp;</span> PFLAG_PRESSED) <span style=color:#f92672>!=</span> 0) {
</span></span><span style=display:flex><span>        setPressed(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (((viewFlags <span style=color:#f92672>&amp;</span> CLICKABLE) <span style=color:#f92672>==</span> CLICKABLE
</span></span><span style=display:flex><span>            <span style=color:#f92672>||</span> (viewFlags <span style=color:#f92672>&amp;</span> LONG_CLICKABLE) <span style=color:#f92672>==</span> LONG_CLICKABLE)
</span></span><span style=display:flex><span>            <span style=color:#f92672>||</span> (viewFlags <span style=color:#f92672>&amp;</span> CONTEXT_CLICKABLE) <span style=color:#f92672>==</span> CONTEXT_CLICKABLE);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>即使 View 为 disabled 状态也能消耗事件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>if</span> (((viewFlags <span style=color:#f92672>&amp;</span> CLICKABLE) <span style=color:#f92672>==</span> CLICKABLE <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>        (viewFlags <span style=color:#f92672>&amp;</span> LONG_CLICKABLE) <span style=color:#f92672>==</span> LONG_CLICKABLE) <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>        (viewFlags <span style=color:#f92672>&amp;</span> CONTEXT_CLICKABLE) <span style=color:#f92672>==</span> CONTEXT_CLICKABLE) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 只要 clickable | longClickable 其中一个为 true 就能执行这里，onTouchEvent 就会返回 true</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> (action) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> MotionEvent.<span style=color:#a6e22e>ACTION_UP</span>:
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 当手指抬起时</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>boolean</span> prepressed <span style=color:#f92672>=</span> (mPrivateFlags <span style=color:#f92672>&amp;</span> PFLAG_PREPRESSED) <span style=color:#f92672>!=</span> 0;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> ((mPrivateFlags <span style=color:#f92672>&amp;</span> PFLAG_PRESSED) <span style=color:#f92672>!=</span> 0 <span style=color:#f92672>||</span> prepressed) {
</span></span><span style=display:flex><span>                ...
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>mHasPerformedLongPress <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>mIgnoreNextUpEvent) {
</span></span><span style=display:flex><span>                    removeLongPressCallback();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>focusTaken) {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (mPerformClick <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                            mPerformClick <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> PerformClick();
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>post(mPerformClick)) {
</span></span><span style=display:flex><span>                            <span style=color:#75715e>// performClick 将会调用 onClick</span>
</span></span><span style=display:flex><span>                            performClick();
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                ...
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            ...
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们接着看 performClick 方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>performClick</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> result;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> ListenerInfo li <span style=color:#f92672>=</span> mListenerInfo;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (li <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> li.<span style=color:#a6e22e>mOnClickListener</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 点击音</span>
</span></span><span style=display:flex><span>        playSoundEffect(SoundEffectConstants.<span style=color:#a6e22e>CLICK</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// onClick 在这</span>
</span></span><span style=display:flex><span>        li.<span style=color:#a6e22e>mOnClickListener</span>.<span style=color:#a6e22e>onClick</span>(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>        result <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        result <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sendAccessibilityEvent(AccessibilityEvent.<span style=color:#a6e22e>TYPE_VIEW_CLICKED</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>还没结束，我们再看一看 setOnClickListener 方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setOnClickListener</span>(OnClickListener l) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>isClickable) {
</span></span><span style=display:flex><span>        setClickable(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    getListenerInfo.<span style=color:#a6e22e>mOnClickListener</span> <span style=color:#f92672>=</span> l;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到在设置 View 的 OnClickListener会自动改变 View 的 clickable 属性，而 setOnLongClickListener 也是一样的。</p><h1 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h1><ol><li>事件分发机制就是点击事件的分发，在手指接触屏幕后产生的同一个事件序列都是点击事件。</li><li>点击事件的传递顺序是由外向内。</li><li>正常情况下一个事件序列只能被一个 View 拦截且消耗。</li><li>如果 View 决定拦截事件，那么这一个事件序列都会由这个View来处理。</li><li>当子 View 拦截却不不消耗点击事件，那点击事件将交由给他的父View去处理，如果所有的 View 都没有消耗掉点击事件（onTouchEvent 返回 false），最终 Activity 会调用自己的 onTouchEvent。</li><li>onInterceptTouchEvent 方法不一定会每次都执行，一个 View 一旦决定拦截将不会调用 onInterceptTouchEvent</li><li>OnTouchListener的优先级高于onTouchEvent()。这样做的好处是方便在外部处理事件。</li><li>当我们把 View 设置为不可用状态，View 依然会消耗事件。</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://moonlab.top/tags/android/>Android</a></li></ul></footer><script src=https://comment.moonlab.top/moontalk.js></script><div id=container></div><script>(new MoonTalk).init({page_key:window.location.href,server:"https:///comment.moonlab.top",element:"#container"})</script></article></main><aside class=rightbar><div class=rightbar-categories><h3>分类</h3><ul class=rightbar-categories-first-list><li><a href=https://moonlab.top/categories/programming/>Programming</a> (16)<ul class=rightbar-categories-sec-list><li><a href=/tags/embeded>Embeded</a></li><li><a href=/tags/golang>golang</a></li><li><a href=/tags/linux>Linux</a></li><li><a href=/tags/android>Android</a></li></ul></li><li><a href=https://moonlab.top/categories/reverse/>Reverse</a> (1)<ul class=rightbar-categories-sec-list><li><a href=/tags/javascript>JavaScript</a></li></ul></li><li><a href=https://moonlab.top/categories/%E5%85%B6%E4%BB%96/>其他</a> (5)<ul class=rightbar-categories-sec-list><li><a href=/tags/blog>blog</a></li></ul></li><li><a href=https://moonlab.top/categories/%E7%AE%97%E6%B3%95/>算法</a> (4)<ul class=rightbar-categories-sec-list></ul></li></ul></div></aside></div><footer class=footer><img id=mooncounter-img style="margin:0 auto;margin-bottom:6px"></img>
<script src="//counter.moonlab.top/img?name=https://moonlab.top/"></script><span>&copy; 2025 <a href=https://moonlab.top/>MoonLab</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span><a href=https://www.travellings.cn/go.html rel=noopener target=_blank><img style=height:27px alt=travelling src=https://www.travellings.cn/assets/logo.svg></a></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>