<!doctype html><html lang=cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>快速求解平方根倒数算法 | MoonLab</title>
<meta name=keywords content><meta name=description content="本文介绍了一种快速计算平方根倒数的算法，该算法源于上世纪90年代。文章首先解释了浮点数在计算机中的存储方式，特别是float32格式的结构，包括符号位、指数位和尾数位。接着，介绍了牛顿迭代法的基本原理及其在求解平方根倒数中的应用。通过对浮点数的对数变换，推导出与平方根倒数相关的公式，并解释了代码中使用的神秘常数 0x5f3759df 的来源，最后提到切比雪夫最佳逼近的概念，以优化计算结果。"><meta name=author content="LingC"><link rel=canonical href=https://moonlab.top/posts/2025/alg-graphics-1/><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"],["$","$"]]},loader:{load:["ui/safe"]}}</script><link crossorigin=anonymous href=/assets/css/stylesheet.1ff5a7b3bb4a96bf1747dfa25e8031167d4537d7ae4b78fac2b752886047a06e.css rel="preload stylesheet" as=style><link rel=icon href=/moon.svg type=image/svg+xml><link rel=icon type=image/png sizes=16x16 href=https://moonlab.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://moonlab.top/favicon-32x32.png><link rel=apple-touch-icon href=https://moonlab.top/apple-touch-icon.png><link rel=mask-icon href=https://moonlab.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=cn href=https://moonlab.top/posts/2025/alg-graphics-1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="快速求解平方根倒数算法"><meta property="og:description" content="本文介绍了一种快速计算平方根倒数的算法，该算法源于上世纪90年代。文章首先解释了浮点数在计算机中的存储方式，特别是float32格式的结构，包括符号位、指数位和尾数位。接着，介绍了牛顿迭代法的基本原理及其在求解平方根倒数中的应用。通过对浮点数的对数变换，推导出与平方根倒数相关的公式，并解释了代码中使用的神秘常数 0x5f3759df 的来源，最后提到切比雪夫最佳逼近的概念，以优化计算结果。"><meta property="og:type" content="article"><meta property="og:url" content="https://moonlab.top/posts/2025/alg-graphics-1/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-04T21:35:38+08:00"><meta property="article:modified_time" content="2025-02-04T21:35:38+08:00"><meta property="og:site_name" content="MoonLab"><meta name=twitter:card content="summary"><meta name=twitter:title content="快速求解平方根倒数算法"><meta name=twitter:description content="本文介绍了一种快速计算平方根倒数的算法，该算法源于上世纪90年代。文章首先解释了浮点数在计算机中的存储方式，特别是float32格式的结构，包括符号位、指数位和尾数位。接着，介绍了牛顿迭代法的基本原理及其在求解平方根倒数中的应用。通过对浮点数的对数变换，推导出与平方根倒数相关的公式，并解释了代码中使用的神秘常数 0x5f3759df 的来源，最后提到切比雪夫最佳逼近的概念，以优化计算结果。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://moonlab.top/posts/"},{"@type":"ListItem","position":2,"name":"快速求解平方根倒数算法","item":"https://moonlab.top/posts/2025/alg-graphics-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"快速求解平方根倒数算法","name":"快速求解平方根倒数算法","description":"本文介绍了一种快速计算平方根倒数的算法，该算法源于上世纪90年代。文章首先解释了浮点数在计算机中的存储方式，特别是float32格式的结构，包括符号位、指数位和尾数位。接着，介绍了牛顿迭代法的基本原理及其在求解平方根倒数中的应用。通过对浮点数的对数变换，推导出与平方根倒数相关的公式，并解释了代码中使用的神秘常数 0x5f3759df 的来源，最后提到切比雪夫最佳逼近的概念，以优化计算结果。","keywords":[],"articleBody":"对于快速计算出平方根倒数 $\\frac{1}{\\sqrt{x}}$，有一个上世纪90年代的经典算法：\nfloat Q_rsqrt( float number ) { long i; float x2, y; const float threehalfs = 1.5F; x2 = number * 0.5F; y = number; i = * ( long * ) \u0026y; // evil floating point bit level hacking i = 0x5f3759df - ( i \u003e\u003e 1 ); // what the fuck? y = * ( float * ) \u0026i; y = y * ( threehalfs - ( x2 * y * y ) ); // 1st iteration // y = y * ( threehalfs - ( x2 * y * y ) ); // 2nd iteration, this can be removed return y; } 扫盲：浮点数在计算机中的储存 float32和double64都由 IEE754 标准定义，在这里只简单了解float32。\n在这32位中分为三个部分:\nSign 符号：0代表整数，1代表负数 Exponent 指数位 二进制的8bit可以表示256种状态，而IEE754规定，这八位用于表示[-127, 127]范围内的指数。 为了方便地表示负数，其规定在float32中指数的偏移量为127，因此指数的实际值为e = exponent - 127。 这将确保以二进制储存的biased exponent总是非负整数。\nFraction 尾数位 尾数位在格式中有23位，因此可以表示的精度为2^-23，约等于1.19 * 10^-7。\n如有一个十进制数13.62，将整数部分除2取余逆序排列为1101，将小数部分乘2取整顺序排列为101。这个十进制小数在二进制的表示为1101.101，即1.101101 * 2^3。\n将指数部分加上偏移量127，得到130，则exponent部分的值为10000010。\n因为规定了小数的最高位总是非零数，所以在二进制中它总是为1，因此在尾数部分可以省略最高位的储存，只考虑小数点后面的数字。如凑不够23位则低位补零。\n$$ {\\text{value}}=(-1)^{\\text{sign}}\\times 2^{(E-127)}\\times \\left(1+\\frac{M}{2^{23}}\\right) $$其中，$\\frac{M}{2^{23}}$ 将尾数 $M$ 归一化到范围 $[0, 1)$。\n牛顿迭代法求根 对于 $ f(x)=0 $ 有一个近似解 $ x_n $，通过给出的根得到更近似的根。\n$$ x_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)} $$ 已经证明牛顿迭代法的二次收敛条件： ${\\displaystyle f'(x)\\neq 0}$ ; ${\\displaystyle x\\in I}$，其中 ${\\displaystyle I}$ 为区间$[α − r, α + r]$ ; ${\\displaystyle f(x)}$ 在 ${\\displaystyle I}$ 上连续可微; 初始根 $x_0$ 足够接近根 $x_*$\n最开始的浮点数公式： $x=\\left(1+\\frac{M}{2^{23}}\\right) 2^{(E-127)}$\n两边同取对数，\n$$ \\begin{align} \\log_{2}(x) \u0026= \\log_{2}(\\left(1+\\frac{M}{2^{23}}\\right) 2^{(E-127)}) \\\\ \u0026= \\left(E-127\\right)+\\log_{2}(1+\\frac{M}{2^{23}}) \\end{align} $$在$ x \\in [0, 1]$，$\\log_{2}(1+x) \\approx x$，$ y=\\log_{2}(1+x) $ 与 $y=x$ 在图像上十分接近。 $$ \\begin{align} \\log_{2}(x) \u0026= \\left(E-127\\right)+\\log_{2}(1+\\frac{M}{2^{23}})\\\\ \u0026= \\frac{M}{2^{23}}+E-127 \\\\ \u0026= \\frac{M+2^{23} \\times E}{2^{23}}-127 \\end{align} $$此时，$M+2^{23}E$ 就是浮点数在二进制中的表达，其中 $2^{23}$ 使 $E$ 在二进制中向左移23位。\n$log_{2}(x) = \\frac{M+2^{23} \\times E}{2^{23}}-127 $ 其实就是浮点数 $x$ 与其在二进制中的关系\n设有解 $a=\\frac{1}{\\sqrt{y}}$\n$\\log_{2}(a) = \\log_{2}(\\frac{1}{\\sqrt{y}}) = -\\frac{1}{2}\\log_{2}(y)$\n将浮点数 $a$ 和 $y$ 转化为二进制形式 $A, Y$，代入上式，得到\n$\\frac{A}{2^{23}}-127 = -\\frac{1}{2}\\left( \\frac{Y}{2^{23}}-127 \\right) $\n$A = 381 \\times 2^{22} + α - \\frac{1}{2}Y$\n这个式子，其实就是这行代码的含义：\ni = 0x5f3759df - ( i \u003e\u003e 1 ); // what the fuck? 但 0x5f3759df 这个值是怎么来的呢？或句话说，如何计算出最佳的修正因子$α$？\n引入一个修正因子$α$，使得直线 $y=x$ 上移与 $y=\\log_{2}(1+x)$ 在图像上更加接近。\n$$\\log_{2}(1+x) \\approx x+α$$切比雪夫最佳逼近 $$ E(\\alpha) = \\max_{x \\in [0,b]} \\left| (x + \\alpha) - \\log_2(1 + x) \\right| $$最佳逼近直线为\n$$y=x+0.0431$$ Refs\nfloat32 Picture (By Fresheneesz at the English Wikipedia project, CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=3357169)\nNewtonMethod Picture 作者 Ralf Pfeifer - de:Image:NewtonIteration Ani.gif，CC BY-SA 3.0，https://commons.wikimedia.org/w/index.php?curid=2268473\n","wordCount":"336","inLanguage":"cn","datePublished":"2025-02-04T21:35:38+08:00","dateModified":"2025-02-04T21:35:38+08:00","author":{"@type":"Person","name":"LingC"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://moonlab.top/posts/2025/alg-graphics-1/"},"publisher":{"@type":"Organization","name":"MoonLab","logo":{"@type":"ImageObject","url":"https://moonlab.top/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://moonlab.top/ accesskey=h title="MoonLab (Alt + H)"><img src=/moon.svg alt aria-label=logo height=20>MoonLab</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://moonlab.top/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://moonlab.top/archives/ title=归档><span>归档</span></a></li><li><a href=https://moonlab.top/search/ title=搜索><span>搜索</span></a></li><li><a href=https://moonlab.top/about/ title=关于><span>关于</span></a></li><li><a href=https://www.travellings.cn/go.html target=_blank title=开往><span>开往</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><div class=body-layout><div class=leftbar></div><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">快速求解平方根倒数算法</h1><div class=post-meta><span title='2025-02-04 21:35:38 +0800 +0800'>February 4, 2025</span>&nbsp;·&nbsp;LingC</div></header><div class=post-summary><span class=bold-text>📦 由AI生成的摘要</span><br><span class=post-summary-main>本文介绍了一种快速计算平方根倒数的算法，该算法源于上世纪90年代。文章首先解释了浮点数在计算机中的存储方式，特别是float32格式的结构，包括符号位、指数位和尾数位。接着，介绍了牛顿迭代法的基本原理及其在求解平方根倒数中的应用。通过对浮点数的对数变换，推导出与平方根倒数相关的公式，并解释了代码中使用的神秘常数 0x5f3759df 的来源，最后提到切比雪夫最佳逼近的概念，以优化计算结果。</span></div><div class=post-content><p>对于快速计算出平方根倒数 $\frac{1}{\sqrt{x}}$，有一个上世纪90年代的经典算法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>float</span> <span style=color:#a6e22e>Q_rsqrt</span>( <span style=color:#66d9ef>float</span> number )
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>long</span> i;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> x2, y;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span> threehalfs <span style=color:#f92672>=</span> <span style=color:#ae81ff>1.5F</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    x2 <span style=color:#f92672>=</span> number <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.5F</span>;
</span></span><span style=display:flex><span>    y  <span style=color:#f92672>=</span> number;
</span></span><span style=display:flex><span>    i  <span style=color:#f92672>=</span> <span style=color:#f92672>*</span> ( <span style=color:#66d9ef>long</span> <span style=color:#f92672>*</span> ) <span style=color:#f92672>&amp;</span>y;                       <span style=color:#75715e>// evil floating point bit level hacking
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    i  <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x5f3759df</span> <span style=color:#f92672>-</span> ( i <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span> );               <span style=color:#75715e>// what the fuck? 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    y  <span style=color:#f92672>=</span> <span style=color:#f92672>*</span> ( <span style=color:#66d9ef>float</span> <span style=color:#f92672>*</span> ) <span style=color:#f92672>&amp;</span>i;
</span></span><span style=display:flex><span>    y  <span style=color:#f92672>=</span> y <span style=color:#f92672>*</span> ( threehalfs <span style=color:#f92672>-</span> ( x2 <span style=color:#f92672>*</span> y <span style=color:#f92672>*</span> y ) );   <span style=color:#75715e>// 1st iteration
</span></span></span><span style=display:flex><span><span style=color:#75715e>//  y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> y;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=扫盲浮点数在计算机中的储存>扫盲：浮点数在计算机中的储存<a hidden class=anchor aria-hidden=true href=#扫盲浮点数在计算机中的储存>#</a></h1><p>float32和double64都由 IEE754 标准定义，在这里只简单了解float32。</p><p><img loading=lazy src=Float_example.svg alt=float></p><p>在这32位中分为三个部分:</p><ul><li>Sign 符号：0代表整数，1代表负数</li><li>Exponent 指数位</li></ul><p>二进制的8bit可以表示256种状态，而IEE754规定，这八位用于表示<code>[-127, 127]</code>范围内的指数。
为了方便地表示负数，其规定在float32中指数的偏移量为127，因此指数的实际值为<code>e = exponent - 127</code>。
这将确保以二进制储存的<code>biased exponent</code>总是非负整数。</p><ul><li>Fraction 尾数位</li></ul><p>尾数位在格式中有23位，因此可以表示的精度为<code>2^-23</code>，约等于<code>1.19 * 10^-7</code>。</p><p>如有一个十进制数<code>13.62</code>，将整数部分除2取余逆序排列为<code>1101</code>，将小数部分乘2取整顺序排列为<code>101</code>。这个十进制小数在二进制的表示为<code>1101.101</code>，即<code>1.101101 * 2^3</code>。</p><p>将指数部分加上偏移量127，得到130，则<code>exponent</code>部分的值为<code>10000010</code>。</p><p>因为规定了小数的最高位总是非零数，所以在二进制中它总是为<code>1</code>，因此在尾数部分可以省略最高位的储存，只考虑小数点后面的数字。如凑不够23位则低位补零。</p>$$
{\text{value}}=(-1)^{\text{sign}}\times 2^{(E-127)}\times \left(1+\frac{M}{2^{23}}\right)
$$<p>其中，$\frac{M}{2^{23}}$ 将尾数 $M$ 归一化到范围 $[0, 1)$。</p><h1 id=牛顿迭代法求根>牛顿迭代法求根<a hidden class=anchor aria-hidden=true href=#牛顿迭代法求根>#</a></h1><p>对于 $ f(x)=0 $ 有一个近似解 $ x_n $，通过给出的根得到更近似的根。</p>$$
x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}
$$<p><img loading=lazy src=NewtonIteration_Ani.gif alt=NewtonMethod></p><p>已经证明牛顿迭代法的二次收敛条件：
${\displaystyle f'(x)\neq 0}$ ; ${\displaystyle x\in I}$，其中 ${\displaystyle I}$ 为区间$[α − r, α + r]$ ; ${\displaystyle f(x)}$ 在 ${\displaystyle I}$ 上连续可微; 初始根 $x_0$ 足够接近根 $x_*$</p><p>最开始的浮点数公式：
$x=\left(1+\frac{M}{2^{23}}\right) 2^{(E-127)}$</p><p>两边同取对数，</p>$$
\begin{align}
\log_{2}(x) &= \log_{2}(\left(1+\frac{M}{2^{23}}\right) 2^{(E-127)}) \\
&= \left(E-127\right)+\log_{2}(1+\frac{M}{2^{23}})
\end{align}
$$<p>在$ x \in [0, 1]$，$\log_{2}(1+x) \approx x$，$ y=\log_{2}(1+x) $ 与 $y=x$ 在图像上十分接近。
<img loading=lazy src=desmos-graph.png alt></p>$$
\begin{align}
\log_{2}(x) &= \left(E-127\right)+\log_{2}(1+\frac{M}{2^{23}})\\
&= \frac{M}{2^{23}}+E-127 \\
&= \frac{M+2^{23} \times E}{2^{23}}-127
\end{align}
$$<p>此时，$M+2^{23}E$ 就是浮点数在二进制中的表达，其中 $2^{23}$ 使 $E$ 在二进制中向左移23位。</p><p>$log_{2}(x) = \frac{M+2^{23} \times E}{2^{23}}-127 $ 其实就是浮点数 $x$ 与其在二进制中的关系</p><p>设有解 $a=\frac{1}{\sqrt{y}}$</p><p>$\log_{2}(a) = \log_{2}(\frac{1}{\sqrt{y}}) = -\frac{1}{2}\log_{2}(y)$</p><p>将浮点数 $a$ 和 $y$ 转化为二进制形式 $A, Y$，代入上式，得到</p><p>$\frac{A}{2^{23}}-127 = -\frac{1}{2}\left( \frac{Y}{2^{23}}-127 \right) $</p><p>$A = 381 \times 2^{22} + α - \frac{1}{2}Y$</p><p>这个式子，其实就是这行代码的含义：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>i  <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x5f3759df</span> <span style=color:#f92672>-</span> ( i <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span> );               <span style=color:#75715e>// what the fuck? 
</span></span></span></code></pre></div><p>但 <code>0x5f3759df</code> 这个值是怎么来的呢？或句话说，如何计算出最佳的修正因子$α$？</p><p>引入一个修正因子$α$，使得直线 $y=x$ 上移与 $y=\log_{2}(1+x)$ 在图像上更加接近。</p>$$\log_{2}(1+x) \approx x+α$$<h1 id=切比雪夫最佳逼近>切比雪夫最佳逼近<a hidden class=anchor aria-hidden=true href=#切比雪夫最佳逼近>#</a></h1>$$
E(\alpha) = \max_{x \in [0,b]} \left| (x + \alpha) - \log_2(1 + x) \right|
$$<p>最佳逼近直线为</p>$$y=x+0.0431$$<hr><p>Refs</p><p>float32 Picture
(By Fresheneesz at the English Wikipedia project, CC BY-SA 3.0, <a href="https://commons.wikimedia.org/w/index.php?curid=3357169">https://commons.wikimedia.org/w/index.php?curid=3357169</a>)</p><p>NewtonMethod Picture
作者 Ralf Pfeifer - de:Image:NewtonIteration Ani.gif，CC BY-SA 3.0，https://commons.wikimedia.org/w/index.php?curid=2268473</p></div><footer class=post-footer><ul class=post-tags></ul></footer><script src=https://comment.moonlab.top/moontalk.js></script><div id=container></div><script>(new MoonTalk).init({page_key:window.location.href,server:"https:///comment.moonlab.top",element:"#container"})</script></article></main><aside class=rightbar><div class=rightbar-categories><h3>分类</h3><ul class=rightbar-categories-first-list><li><a href=https://moonlab.top/categories/programming/>Programming</a> (16)<ul class=rightbar-categories-sec-list><li><a href=/tags/embeded>Embeded</a></li><li><a href=/tags/golang>golang</a></li><li><a href=/tags/linux>Linux</a></li><li><a href=/tags/android>Android</a></li></ul></li><li><a href=https://moonlab.top/categories/reverse/>Reverse</a> (1)<ul class=rightbar-categories-sec-list><li><a href=/tags/javascript>JavaScript</a></li></ul></li><li><a href=https://moonlab.top/categories/%E5%85%B6%E4%BB%96/>其他</a> (5)<ul class=rightbar-categories-sec-list><li><a href=/tags/blog>blog</a></li></ul></li><li><a href=https://moonlab.top/categories/%E7%AE%97%E6%B3%95/>算法</a> (4)<ul class=rightbar-categories-sec-list></ul></li></ul></div></aside></div><footer class=footer><img id=mooncounter-img style="margin:0 auto;margin-bottom:6px"></img>
<script src="//counter.moonlab.top/img?name=https://moonlab.top/"></script><span>&copy; 2025 <a href=https://moonlab.top/>MoonLab</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span><a href=https://www.travellings.cn/go.html rel=noopener target=_blank><img style=height:27px alt=travelling src=https://www.travellings.cn/assets/logo.svg></a></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>