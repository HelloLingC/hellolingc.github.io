<!doctype html><html lang=cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Android Shizuku源码分析 第二篇 | MoonLab</title>
<meta name=keywords content="Android"><meta name=description content="本文深入分析了 Shizuku 的启动过程，特别是 Starter 类的 main 方法是如何被调用的。文章首先回顾了 Shizuku 的基本概念，并介绍了通过 adb 命令激活 ShizukuService 的过程，重点分析了 start.sh 脚本的执行。当用户通过 ShizukuManager 启动应用时，start.sh 脚本被调用，该脚本负责设置环境并执行 libshizuku.so 文件。文章详细描述了 ShizukuManager 在启动时如何写入 start.sh 文件及其相关的 dex 文件路径。接着，文章探讨了 libshizuku.so 中的 main 方法，说明了如何通过 app_process 启动 Java 类 moe.shizuku.server.Starter。在 Starter 类的 main 方法中，创建了 ShizukuService 实例，从而完成了 ShizukuService 的启动。最后，作者总结了整个过程，强调了用户通过简单的 adb 命令如何触发一系列复杂的操作，最终实现 Shizuku 的功能。"><meta name=author content="LingC"><link rel=canonical href=https://moonlab.top/posts/2020/android-shizuku-theory2/><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"],["$","$"]]},loader:{load:["ui/safe"]}}</script><link crossorigin=anonymous href=/assets/css/stylesheet.1ff5a7b3bb4a96bf1747dfa25e8031167d4537d7ae4b78fac2b752886047a06e.css rel="preload stylesheet" as=style><link rel=icon href=/moon.svg type=image/svg+xml><link rel=icon type=image/png sizes=16x16 href=https://moonlab.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://moonlab.top/favicon-32x32.png><link rel=apple-touch-icon href=https://moonlab.top/apple-touch-icon.png><link rel=mask-icon href=https://moonlab.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=cn href=https://moonlab.top/posts/2020/android-shizuku-theory2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Android Shizuku源码分析 第二篇"><meta property="og:description" content="本文深入分析了 Shizuku 的启动过程，特别是 Starter 类的 main 方法是如何被调用的。文章首先回顾了 Shizuku 的基本概念，并介绍了通过 adb 命令激活 ShizukuService 的过程，重点分析了 start.sh 脚本的执行。当用户通过 ShizukuManager 启动应用时，start.sh 脚本被调用，该脚本负责设置环境并执行 libshizuku.so 文件。文章详细描述了 ShizukuManager 在启动时如何写入 start.sh 文件及其相关的 dex 文件路径。接着，文章探讨了 libshizuku.so 中的 main 方法，说明了如何通过 app_process 启动 Java 类 moe.shizuku.server.Starter。在 Starter 类的 main 方法中，创建了 ShizukuService 实例，从而完成了 ShizukuService 的启动。最后，作者总结了整个过程，强调了用户通过简单的 adb 命令如何触发一系列复杂的操作，最终实现 Shizuku 的功能。"><meta property="og:type" content="article"><meta property="og:url" content="https://moonlab.top/posts/2020/android-shizuku-theory2/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-02-04T11:43:10+00:00"><meta property="article:modified_time" content="2020-02-04T11:43:10+00:00"><meta property="og:site_name" content="MoonLab"><meta name=twitter:card content="summary"><meta name=twitter:title content="Android Shizuku源码分析 第二篇"><meta name=twitter:description content="本文深入分析了 Shizuku 的启动过程，特别是 Starter 类的 main 方法是如何被调用的。文章首先回顾了 Shizuku 的基本概念，并介绍了通过 adb 命令激活 ShizukuService 的过程，重点分析了 start.sh 脚本的执行。当用户通过 ShizukuManager 启动应用时，start.sh 脚本被调用，该脚本负责设置环境并执行 libshizuku.so 文件。文章详细描述了 ShizukuManager 在启动时如何写入 start.sh 文件及其相关的 dex 文件路径。接着，文章探讨了 libshizuku.so 中的 main 方法，说明了如何通过 app_process 启动 Java 类 moe.shizuku.server.Starter。在 Starter 类的 main 方法中，创建了 ShizukuService 实例，从而完成了 ShizukuService 的启动。最后，作者总结了整个过程，强调了用户通过简单的 adb 命令如何触发一系列复杂的操作，最终实现 Shizuku 的功能。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://moonlab.top/posts/"},{"@type":"ListItem","position":2,"name":"Android Shizuku源码分析 第二篇","item":"https://moonlab.top/posts/2020/android-shizuku-theory2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Android Shizuku源码分析 第二篇","name":"Android Shizuku源码分析 第二篇","description":"本文深入分析了 Shizuku 的启动过程，特别是 Starter 类的 main 方法是如何被调用的。文章首先回顾了 Shizuku 的基本概念，并介绍了通过 adb 命令激活 ShizukuService 的过程，重点分析了 start.sh 脚本的执行。当用户通过 ShizukuManager 启动应用时，start.sh 脚本被调用，该脚本负责设置环境并执行 libshizuku.so 文件。文章详细描述了 ShizukuManager 在启动时如何写入 start.sh 文件及其相关的 dex 文件路径。接着，文章探讨了 libshizuku.so 中的 main 方法，说明了如何通过 app_process 启动 Java 类 moe.shizuku.server.Starter。在 Starter 类的 main 方法中，创建了 ShizukuService 实例，从而完成了 ShizukuService 的启动。最后，作者总结了整个过程，强调了用户通过简单的 adb 命令如何触发一系列复杂的操作，最终实现 Shizuku 的功能。","keywords":["Android"],"articleBody":"又是前言 上一篇的 Shizuku 源码分析，我大概从我们开发的应用到 ShizukuService 再到 SystemService 都通了一遍。在文章的结尾我只提到了 moe.shizuku.service 包下的 Starter 这个 Java 类的 main 方法启动了整个 ShizukuService ，所以我们才能愉快地调用 Shizuku 的 API。\n我们接下来要更深入分析，去 Navtive 层看看。我想要知道 Starter 的 main 方法又是谁调用的？怎么调用的？\nShizuku 是什么？我就不再多说了。\nGithub: https://github.com/RikkaApps/Shizuku\n（之后会简单涉及到 Android 中的 NDK 开发，和一些 C++ 的内容）\nstart.sh 当用户使用 ShizukuManager ，通过 ShizukuManager 激活应用时，需要先启动 ShizukuService 。\n这里有 adb 和 root 两种启动方式，我们只分析 adb 方式。\nadb shell sh /sdcard/Android/data/moe.shizuku.privileged.api/files/start.sh 这条 adb 命令想必用过 ShizukuManager 的人都很熟悉吧？只要在 adb 终端输入这条命令，就能激活 ShizukuManager。\n这条命令很简单，就是调用 sh 脚本 start.sh 。这个 start.sh 在源码中 manager 模块的 raw 文件夹中：\n这个 shell 脚本的内容是什么我们等会再看，我们先要知道 ShizukuManager 这个 APP 在启动时干了什么 ，看看 Manager 的 MainActivity 的 onCreate 方法：\nprivate static boolean sWriteFilesCalled; @Override protected void onCreate(Bundle savedInstanceState) { if (!sWriteFilesCalled) { ServerLauncher.writeFiles(this, true); sWriteFilesCalled = true; } } 这里调用了 ServiceLauncher 的 writeFiles 方法，让我们来康康：\npublic static void writeFiles(Context context, boolean external) { // 从 MainActivity 传入的 external 是 true try { File out; if (external) // 执行这里，得到 /sdcard/Android/data/com.example.app/files/ out = context.getExternalFilesDir(null); else out = getParent(context); if (out == null) return; int apiVersion = Math.min(ShizukuLegacy.MAX_SDK, Build.VERSION.SDK_INT); String source = String.format(Locale.ENGLISH, \"server-v2-%d.dex\", apiVersion); // 此时 i 为 1 int i = external ? 1 : 0; // copyDex DEX_LEGACY_PATH[i] = copyDex(context, source, new File(out, V2_DEX_NAME)); DEX_PATH[i] = copyDex(context, \"server.dex\", new File(out, V3_DEX_NAME)); // 注意注意这个 writeShellFile 方法 String command = writeShellFile(context, new File(out, \"start.sh\"), DEX_LEGACY_PATH[i], DEX_PATH[i]); // external 为 true ，不执行 if (!external) { COMMAND_ROOT = command; } } catch (IOException e) { e.printStackTrace(); } } 看到 writeShellFile 这个方法了吗？里面的参数是一个 File 类和一个 “start.sh”，还有两个 dex 文件路径。\n继续看 ServiceLauncher#writeShellFile：\nprivate static String writeShellFile(Context context, File out, String dexLegacy, String dex) throws IOException { if (!out.exists()) { //noinspection ResultOfMethodCallIgnored out.createNewFile(); } BufferedReader is = new BufferedReader(new InputStreamReader(context.getResources().openRawResource(R.raw.start))); PrintWriter os = new PrintWriter(new FileWriter(out)); String line; while ((line = is.readLine()) != null) { // 这里将 start.sh 写出，并把 start.sh 的那些文字替换成路径值。 os.println(line .replace(\"%%%STARTER_PATH%%%\", getLibPath(context, \"libshizuku.so\")) .replace(\"%%%STARTER_PARAM%%%\", getStarterParam(dexLegacy, dex)) .replace(\"%%%LIBRARY_PATH%%%\", getLibPath(context, \"libhelper.so\")) ); } os.flush(); os.close(); return \"sh \" + out.getAbsolutePath(); } 还记得我们之前看的那个 start.sh 的内容吗？这里实际上就是把 raw 内的 start.sh 写出放到 /sdcard/Android/data/moe.shizuku.privileged.api/files。\n这就是为什么那条激活用的 adb 命令能够执行：\nadb shell sh /sdcard/Android/data/moe.shizuku.privileged.api/files/start.sh 看到了吗？如果你安装了 ShizukuManager 并打开了，你可以在 /sdcard/Android/data/moe.shizuku.privileged.api/files 目录里找到这个 start.sh 和两个 dex 文件。\n这俩 dex 文件就是通过 ServiceLauncher#writeFiles 用 copyDex 方法把 assets 的 dex 写出到SD目录。\n同时 start.sh 中的那开头的三个变量也在写出的时候被 ShizukuManager 替换了：\n#!/system/bin/sh // 这三个变量在 ShizukuManager 写出时被替换了 STARTER_PATH=\"%%%STARTER_PATH%%%\" // 对应 libshizuku.so 文件路径 STARTER_PARAM=\"%%%STARTER_PARAM%%%\" // 对应调用 main 函数的参数，里面包含了那两个 dex 文件的路径和 token LIBRARY_PATH=\"%%%LIBRARY_PATH%%%\" // 对应 libhelper.so 文件路径 echo \"info: start.sh begin\" if [[ -f \"$STARTER_PATH\" ]]; then rm -f /data/local/tmp/shizuku_starter // 将 libshizuku.so 文件移动到 // 实际上 /data/local/tmp/ 下的 shizuku_starter 文件就是 libshizuku.so 文件 cp \"$STARTER_PATH\" /data/local/tmp/shizuku_starter // 修改权限 chmod 700 /data/local/tmp/shizuku_starter chown 2000 /data/local/tmp/shizuku_starter chgrp 2000 /data/local/tmp/shizuku_starter // 这似乎是在修改 Selinux 啥的什么东西的啥子命令 chcon u:object_r:shell_data_file:s0 /data/local/tmp/shizuku_starter // 设置环境变量 export PATH=/data/local/tmp:/system/bin:$PATH // 调用 shizku_starter so文件（原来是 libshizuku.so）的 main 方法，传入参数 shizuku_starter ${STARTER_PARAM} $1 // 返回上 shizuku_starer 内 main 函数的返回值 result=$? if [[ ${result} -ne 0 ]]; then echo \"info: shizuku_starter exit with non-zero value $result\" else echo \"info: shizuku_starter exit with 0\" fi else echo \"Starter file not exist, please open Shizuku Manager and try again.\" fi 当我们输入那条用来激活 ShizukuManager 的 adb 命令时候，输出框会噼里啪啦滚出一大堆输出。那些输出是哪里来的？很明显在 start.sh 中没有几条 echo 命令，只能是在 shizuku_starter 的 main 方法里有什么大动作。\n这个 libshizuku.so 文件的原身你可以在 ShizukuManager 源码中的 jni 文件夹中找到，文件名是 starter.cpp。\n没错，它是一个 C++ 文件，我们看看它的 main 方法（我会适当地跳过一些与主题无关的代码）：\n#define SERVER_CLASS_PATH_LEGACY \"moe.shizuku.server.ShizukuServer\" #define SERVER_CLASS_PATH \"moe.shizuku.server.Starter\" int main(int argc, char **argv) { // argc 是传进来的参数的数量，argv是传入的参数的数组。里面包含了 token， 两个 dec 文件的路径 ... char *token = nullptr; char *_path = nullptr; char *_path_legacy = nullptr; int v2 = 1; int i; int use_shell_context = 0; // for 循环，可以看到这是在取出参数 for (i = 0; i \u003c argc; ++i) { if (strncmp(argv[i], \"--token=\", 8) == 0) { token = strdup(argv[i] + 8); } else if (strncmp(argv[i], \"--path=\", 7) == 0) { _path = strdup(argv[i] + 7); } else if (strncmp(argv[i], \"--path-legacy=\", 14) == 0) { _path_legacy = strdup(argv[i] + 14); } else if (strncmp(argv[i], \"--no-v2\", 7) == 0) { v2 = 0; } else if (strncmp(argv[i], \"--use-shell-context\", 19) == 0) { use_shell_context = 1; } } ... // check_acess 会调用 acess 函数判断路径是否有读写权限 check_access(_path, \"source dex path\"); if (v2) check_access(_path_legacy, \"source legacy dex path\"); // 这里我是没看懂的，不知道为什么又建了一个 /data/local/tmp/shizuku 文件夹，将之前 _path 内的文件全部移动到了 path 这个路径里。 mkdir(\"/data/local/tmp/shizuku\", 0707); chmod(\"/data/local/tmp/shizuku\", 0707); ... // 一个 char 数组，也就相当于一个 string char path[PATH_MAX], path_legacy[PATH_MAX]; // 格式化字符，也就是为 path 赋值了 sprintf(path, \"/data/local/tmp/shizuku/%s\", basename(_path)); sprintf(path_legacy, \"/data/local/tmp/shizuku/%s\", basename(_path_legacy)); // 开始复制了，将 _path 路径下的两个 dex 移动到 path 路径 copy_if_not_exist(_path, path); if (v2) copy_if_not_exist(_path_legacy, path_legacy); check_access(path, \"dex path\"); if (v2) check_access(path_legacy, \"legacy dex path\"); printf(\"info: starter begin\\n\"); // 强制输出缓冲区的信息，就是为了快速输出上面的 printf 内容啦 fflush(stdout); ... printf(\"info: starting server v3...\\n\"); fflush(stdout); // 我们重点分析这个 start_service 函数，传入 SERVICE_CLASS_PATH 这个常量，值为 \"moe.shizuku.server.Starter\"，熟悉吗？这就是在应用层的主角啊，用于启动 ShizukuService 的 Java 类。 start_server(path, SERVER_CLASS_PATH, token, SERVER_NAME, use_shell_context); if (v2) { printf(\"info: starting server v2 (legacy)...\\n\"); fflush(stdout); start_server(path_legacy, SERVER_CLASS_PATH_LEGACY, token, SERVER_NAME_LEGACY, false); } exit_with_logcat(EXIT_SUCCESS); // starter.cpp 结束 } 注释上已经大概地说了一遍，我们接下来看 start_service 函数，同样 start_service 也是 starter.cpp 中的一个函数：\nstatic int start_server(const char *path, const char *main_class, const char *token, const char *nice_name, int change_context) { ... /* 省略了很多内容，详细可自己去看看 Shizuku 的源码 */ char buf[128], class_path[PATH_MAX]; sprintf(buf, \"--nice-name=%s\", nice_name); setClasspathEnv(path); snprintf(class_path, PATH_MAX, \"-Djava.class.path=%s\", path); char *appProcessArgs[] = { // app_process 是 Android 里专门用来启动 Java 程序的 const_cast\u003cchar *\u003e(\"/system/bin/app_process\"), class_path, const_cast\u003cchar *\u003e(\"/system/bin\"), const_cast\u003cchar *\u003e(buf), // main_class 值为 \"moe.shizuku.server.Starter\" const_cast\u003cchar *\u003e(main_class), const_cast\u003cchar *\u003e(token), nullptr }; // 调用 app_process 去运行 main_class if (execvp(appProcessArgs[0], appProcessArgs)) { exit_with_logcat(EXIT_FATAL_APP_PROCESS); } ... } 到这里我们的分析已经差不多了。\n我们再仔细说说 app_process 的内容：\n调用 app_process 的话，你需要在参数中提供 dex 文件，同时必须要使 dex 文件有执行权限\napp_process -Djava.class.path=dex文件名 dex所处的目录路径 你要启动的 Java 类（有类名和包名） 我找来了一个参数列表：\nvm-options – VM 选项 cmd-dir –父目录 (/system/bin) options –运行的参数 : –zygote –start-system-server –application (api\u003e=14) –nice-name=nice_proc_name (api\u003e=14) start-class-name –包含main方法的主类 (com.android.commands.am.Am) main-options –启动时候传递到main方法中的参数 小总结 用户通过输入一条 adb 命令去执行 start.sh 文件，start.sh 文件会执行 ShizukuManager 早已准备好的 so 文件。在 so 文件中经过一大堆操作，会通过 app_process 运行 Starter 类的 main 方法，而 Starter 这个 Java 类的 main 方法会直接 new 一个 ShizukuService 使它跑起来。\n看了一上午的代码，翘了一上午的在铛铛的网络课。\n尼玛，都延长假期了和上个屎的网络课。\n","wordCount":"889","inLanguage":"cn","datePublished":"2020-02-04T11:43:10Z","dateModified":"2020-02-04T11:43:10Z","author":{"@type":"Person","name":"LingC"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://moonlab.top/posts/2020/android-shizuku-theory2/"},"publisher":{"@type":"Organization","name":"MoonLab","logo":{"@type":"ImageObject","url":"https://moonlab.top/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://moonlab.top/ accesskey=h title="MoonLab (Alt + H)"><img src=/moon.svg alt aria-label=logo height=20>MoonLab</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://moonlab.top/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://moonlab.top/archives/ title=归档><span>归档</span></a></li><li><a href=https://moonlab.top/search/ title=搜索><span>搜索</span></a></li><li><a href=https://moonlab.top/about/ title=关于><span>关于</span></a></li><li><a href=https://www.travellings.cn/go.html target=_blank title=开往><span>开往</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><div class=body-layout><div class=leftbar></div><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Android Shizuku源码分析 第二篇</h1><div class=post-meta><span title='2020-02-04 11:43:10 +0000 UTC'>February 4, 2020</span>&nbsp;·&nbsp;LingC</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%8f%88%e6%98%af%e5%89%8d%e8%a8%80 aria-label=又是前言>又是前言</a></li><li><a href=#startsh aria-label=start.sh>start.sh</a></li><li><a href=#%e5%b0%8f%e6%80%bb%e7%bb%93 aria-label=小总结>小总结</a></li></ul></div></details></div><div class=post-summary><span class=bold-text>📦 由AI生成的摘要</span><br><span class=post-summary-main>本文深入分析了 Shizuku 的启动过程，特别是 `Starter` 类的 `main` 方法是如何被调用的。文章首先回顾了 Shizuku 的基本概念，并介绍了通过 `adb` 命令激活 ShizukuService 的过程，重点分析了 `start.sh` 脚本的执行。当用户通过 ShizukuManager 启动应用时，`start.sh` 脚本被调用，该脚本负责设置环境并执行 `libshizuku.so` 文件。文章详细描述了 `ShizukuManager` 在启动时如何写入 `start.sh` 文件及其相关的 dex 文件路径。接着，文章探讨了 `libshizuku.so` 中的 `main` 方法，说明了如何通过 `app_process` 启动 Java 类 `moe.shizuku.server.Starter`。在 `Starter` 类的 `main` 方法中，创建了 `ShizukuService` 实例，从而完成了 ShizukuService 的启动。最后，作者总结了整个过程，强调了用户通过简单的 `adb` 命令如何触发一系列复杂的操作，最终实现 Shizuku 的功能。</span></div><div class=post-content><h1 id=又是前言>又是前言<a hidden class=anchor aria-hidden=true href=#又是前言>#</a></h1><p>上一篇的 <a href=https://lcblog.cn/post/android-shizuku-theory>Shizuku 源码分析</a>，我大概从我们开发的应用到 ShizukuService 再到 SystemService 都通了一遍。在文章的结尾我只提到了 moe.shizuku.service 包下的 Starter 这个 Java 类的 main 方法启动了整个 ShizukuService ，所以我们才能愉快地调用 Shizuku 的 API。</p><p>我们接下来要更深入分析，去 Navtive 层看看。我想要知道 Starter 的 main 方法又是谁调用的？怎么调用的？</p><p>Shizuku 是什么？我就不再多说了。</p><p>Github: <a href=https://github.com/RikkaApps/Shizuku>https://github.com/RikkaApps/Shizuku</a></p><p>（之后会简单涉及到 Android 中的 NDK 开发，和一些 C++ 的内容）</p><h1 id=startsh>start.sh<a hidden class=anchor aria-hidden=true href=#startsh>#</a></h1><p>当用户使用 ShizukuManager ，通过 ShizukuManager 激活应用时，需要先启动 ShizukuService 。</p><p>这里有 adb 和 root 两种启动方式，我们只分析 adb 方式。</p><pre tabindex=0><code>adb shell sh /sdcard/Android/data/moe.shizuku.privileged.api/files/start.sh
</code></pre><p>这条 adb 命令想必用过 ShizukuManager 的人都很熟悉吧？只要在 adb 终端输入这条命令，就能激活 ShizukuManager。</p><p>这条命令很简单，就是调用 sh 脚本 start.sh 。这个 start.sh 在源码中 manager 模块的 raw 文件夹中：</p><p>这个 shell 脚本的内容是什么我们等会再看，我们先要知道 ShizukuManager 这个 APP 在启动时干了什么 ，看看 Manager 的 MainActivity 的 onCreate 方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>boolean</span> sWriteFilesCalled;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onCreate</span>(Bundle savedInstanceState) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>sWriteFilesCalled) {
</span></span><span style=display:flex><span>            ServerLauncher.<span style=color:#a6e22e>writeFiles</span>(<span style=color:#66d9ef>this</span>, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>            sWriteFilesCalled <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    	}
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>这里调用了 ServiceLauncher 的 writeFiles 方法，让我们来康康：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>writeFiles</span>(Context context, <span style=color:#66d9ef>boolean</span> external) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 从 MainActivity 传入的 external 是 true</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            File out;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (external)
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 执行这里，得到 /sdcard/Android/data/com.example.app/files/</span>
</span></span><span style=display:flex><span>                out <span style=color:#f92672>=</span> context.<span style=color:#a6e22e>getExternalFilesDir</span>(<span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                out <span style=color:#f92672>=</span> getParent(context);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (out <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> apiVersion <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>min</span>(ShizukuLegacy.<span style=color:#a6e22e>MAX_SDK</span>, Build.<span style=color:#a6e22e>VERSION</span>.<span style=color:#a6e22e>SDK_INT</span>);
</span></span><span style=display:flex><span>            String source <span style=color:#f92672>=</span> String.<span style=color:#a6e22e>format</span>(Locale.<span style=color:#a6e22e>ENGLISH</span>, <span style=color:#e6db74>&#34;server-v2-%d.dex&#34;</span>, apiVersion);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 此时 i 为 1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> external <span style=color:#f92672>?</span> 1 : 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// copyDex</span>
</span></span><span style=display:flex><span>            DEX_LEGACY_PATH<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> copyDex(context, source, <span style=color:#66d9ef>new</span> File(out, V2_DEX_NAME));
</span></span><span style=display:flex><span>            DEX_PATH<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> copyDex(context, <span style=color:#e6db74>&#34;server.dex&#34;</span>, <span style=color:#66d9ef>new</span> File(out, V3_DEX_NAME));
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 注意注意这个 writeShellFile 方法</span>
</span></span><span style=display:flex><span>            String command <span style=color:#f92672>=</span> writeShellFile(context, <span style=color:#66d9ef>new</span> File(out, <span style=color:#e6db74>&#34;start.sh&#34;</span>), DEX_LEGACY_PATH<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>, DEX_PATH<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// external 为 true ，不执行</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>external) {
</span></span><span style=display:flex><span>                COMMAND_ROOT <span style=color:#f92672>=</span> command;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (IOException e) {
</span></span><span style=display:flex><span>            e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>看到 writeShellFile 这个方法了吗？里面的参数是一个 File 类和一个 &ldquo;start.sh&rdquo;，还有两个 dex 文件路径。</p><p>继续看 ServiceLauncher#writeShellFile：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> String <span style=color:#a6e22e>writeShellFile</span>(Context context, File out, String dexLegacy, String dex) <span style=color:#66d9ef>throws</span> IOException {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>out.<span style=color:#a6e22e>exists</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>//noinspection ResultOfMethodCallIgnored</span>
</span></span><span style=display:flex><span>            out.<span style=color:#a6e22e>createNewFile</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        BufferedReader is <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> BufferedReader(<span style=color:#66d9ef>new</span> InputStreamReader(context.<span style=color:#a6e22e>getResources</span>().<span style=color:#a6e22e>openRawResource</span>(R.<span style=color:#a6e22e>raw</span>.<span style=color:#a6e22e>start</span>)));
</span></span><span style=display:flex><span>        PrintWriter os <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> PrintWriter(<span style=color:#66d9ef>new</span> FileWriter(out));
</span></span><span style=display:flex><span>        String line;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> ((line <span style=color:#f92672>=</span> is.<span style=color:#a6e22e>readLine</span>()) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 这里将 start.sh 写出，并把 start.sh 的那些文字替换成路径值。</span>
</span></span><span style=display:flex><span>            os.<span style=color:#a6e22e>println</span>(line
</span></span><span style=display:flex><span>                    .<span style=color:#a6e22e>replace</span>(<span style=color:#e6db74>&#34;%%%STARTER_PATH%%%&#34;</span>, getLibPath(context, <span style=color:#e6db74>&#34;libshizuku.so&#34;</span>))
</span></span><span style=display:flex><span>                    .<span style=color:#a6e22e>replace</span>(<span style=color:#e6db74>&#34;%%%STARTER_PARAM%%%&#34;</span>, getStarterParam(dexLegacy, dex))
</span></span><span style=display:flex><span>                    .<span style=color:#a6e22e>replace</span>(<span style=color:#e6db74>&#34;%%%LIBRARY_PATH%%%&#34;</span>, getLibPath(context, <span style=color:#e6db74>&#34;libhelper.so&#34;</span>))
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        os.<span style=color:#a6e22e>flush</span>();
</span></span><span style=display:flex><span>        os.<span style=color:#a6e22e>close</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;sh &#34;</span> <span style=color:#f92672>+</span> out.<span style=color:#a6e22e>getAbsolutePath</span>();
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>还记得我们之前看的那个 start.sh 的内容吗？这里实际上就是把 raw 内的 start.sh 写出放到 /sdcard/Android/data/moe.shizuku.privileged.api/files。</p><p>这就是为什么那条激活用的 adb 命令能够执行：</p><pre tabindex=0><code>adb shell sh /sdcard/Android/data/moe.shizuku.privileged.api/files/start.sh
</code></pre><p>看到了吗？如果你安装了 ShizukuManager 并打开了，你可以在 /sdcard/Android/data/moe.shizuku.privileged.api/files 目录里找到这个 start.sh 和两个 dex 文件。</p><p>这俩 dex 文件就是通过 ServiceLauncher#writeFiles 用 copyDex 方法把 assets 的 dex 写出到SD目录。</p><p>同时 start.sh 中的那开头的三个变量也在写出的时候被 ShizukuManager 替换了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e>#!/system/bin/sh
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>// 这三个变量在 ShizukuManager 写出时被替换了
</span></span><span style=display:flex><span>STARTER_PATH<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;%%%STARTER_PATH%%%&#34;</span> // 对应 libshizuku.so 文件路径
</span></span><span style=display:flex><span>STARTER_PARAM<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;%%%STARTER_PARAM%%%&#34;</span> // 对应调用 main 函数的参数，里面包含了那两个 dex 文件的路径和 token 
</span></span><span style=display:flex><span>LIBRARY_PATH<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;%%%LIBRARY_PATH%%%&#34;</span> // 对应 libhelper.so 文件路径
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;info: start.sh begin&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[[</span> -f <span style=color:#e6db74>&#34;</span>$STARTER_PATH<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    rm -f /data/local/tmp/shizuku_starter
</span></span><span style=display:flex><span>    // 将 libshizuku.so 文件移动到
</span></span><span style=display:flex><span>    // 实际上 /data/local/tmp/ 下的 shizuku_starter 文件就是 libshizuku.so 文件 
</span></span><span style=display:flex><span>    cp <span style=color:#e6db74>&#34;</span>$STARTER_PATH<span style=color:#e6db74>&#34;</span> /data/local/tmp/shizuku_starter
</span></span><span style=display:flex><span>    // 修改权限
</span></span><span style=display:flex><span>    chmod <span style=color:#ae81ff>700</span> /data/local/tmp/shizuku_starter
</span></span><span style=display:flex><span>    chown <span style=color:#ae81ff>2000</span> /data/local/tmp/shizuku_starter
</span></span><span style=display:flex><span>    chgrp <span style=color:#ae81ff>2000</span> /data/local/tmp/shizuku_starter
</span></span><span style=display:flex><span>    // 这似乎是在修改 Selinux 啥的什么东西的啥子命令
</span></span><span style=display:flex><span>    chcon u:object_r:shell_data_file:s0 /data/local/tmp/shizuku_starter
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	// 设置环境变量
</span></span><span style=display:flex><span>    export PATH<span style=color:#f92672>=</span>/data/local/tmp:/system/bin:$PATH
</span></span><span style=display:flex><span>    // 调用 shizku_starter so文件（原来是 libshizuku.so）的 main 方法，传入参数
</span></span><span style=display:flex><span>    shizuku_starter <span style=color:#e6db74>${</span>STARTER_PARAM<span style=color:#e6db74>}</span> $1
</span></span><span style=display:flex><span>    // 返回上 shizuku_starer 内 main 函数的返回值
</span></span><span style=display:flex><span>    result<span style=color:#f92672>=</span>$?
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[[</span> <span style=color:#e6db74>${</span>result<span style=color:#e6db74>}</span> -ne <span style=color:#ae81ff>0</span> <span style=color:#f92672>]]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        echo <span style=color:#e6db74>&#34;info: shizuku_starter exit with non-zero value </span>$result<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        echo <span style=color:#e6db74>&#34;info: shizuku_starter exit with 0&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;Starter file not exist, please open Shizuku Manager and try again.&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span></code></pre></div><p>当我们输入那条用来激活 ShizukuManager 的 adb 命令时候，输出框会噼里啪啦滚出一大堆输出。那些输出是哪里来的？很明显在 start.sh 中没有几条 echo 命令，只能是在 shizuku_starter 的 main 方法里有什么大动作。</p><p>这个 libshizuku.so 文件的原身你可以在 ShizukuManager 源码中的 jni 文件夹中找到，文件名是 starter.cpp。</p><p>没错，它是一个 C++ 文件，我们看看它的 main 方法（我会适当地跳过一些与主题无关的代码）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>#define SERVER_CLASS_PATH_LEGACY &#34;moe.shizuku.server.ShizukuServer&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define SERVER_CLASS_PATH &#34;moe.shizuku.server.Starter&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// argc 是传进来的参数的数量，argv是传入的参数的数组。里面包含了 token， 两个 dec 文件的路径
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    ...
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>token <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>_path <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>_path_legacy <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> v2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> i;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> use_shell_context <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// for 循环，可以看到这是在取出参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> argc; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (strncmp(argv[i], <span style=color:#e6db74>&#34;--token=&#34;</span>, <span style=color:#ae81ff>8</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            token <span style=color:#f92672>=</span> strdup(argv[i] <span style=color:#f92672>+</span> <span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (strncmp(argv[i], <span style=color:#e6db74>&#34;--path=&#34;</span>, <span style=color:#ae81ff>7</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            _path <span style=color:#f92672>=</span> strdup(argv[i] <span style=color:#f92672>+</span> <span style=color:#ae81ff>7</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (strncmp(argv[i], <span style=color:#e6db74>&#34;--path-legacy=&#34;</span>, <span style=color:#ae81ff>14</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            _path_legacy <span style=color:#f92672>=</span> strdup(argv[i] <span style=color:#f92672>+</span> <span style=color:#ae81ff>14</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (strncmp(argv[i], <span style=color:#e6db74>&#34;--no-v2&#34;</span>, <span style=color:#ae81ff>7</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            v2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (strncmp(argv[i], <span style=color:#e6db74>&#34;--use-shell-context&#34;</span>, <span style=color:#ae81ff>19</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            use_shell_context <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    <span style=color:#75715e>// check_acess 会调用 acess 函数判断路径是否有读写权限
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    check_access(_path, <span style=color:#e6db74>&#34;source dex path&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (v2) check_access(_path_legacy, <span style=color:#e6db74>&#34;source legacy dex path&#34;</span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 这里我是没看懂的，不知道为什么又建了一个 /data/local/tmp/shizuku 文件夹，将之前 _path 内的文件全部移动到了 path 这个路径里。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mkdir(<span style=color:#e6db74>&#34;/data/local/tmp/shizuku&#34;</span>, <span style=color:#ae81ff>0707</span>);
</span></span><span style=display:flex><span>    chmod(<span style=color:#e6db74>&#34;/data/local/tmp/shizuku&#34;</span>, <span style=color:#ae81ff>0707</span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 一个 char 数组，也就相当于一个 string
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>char</span> path[PATH_MAX], path_legacy[PATH_MAX];
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 格式化字符，也就是为 path 赋值了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    sprintf(path, <span style=color:#e6db74>&#34;/data/local/tmp/shizuku/%s&#34;</span>, basename(_path));
</span></span><span style=display:flex><span>    sprintf(path_legacy, <span style=color:#e6db74>&#34;/data/local/tmp/shizuku/%s&#34;</span>, basename(_path_legacy));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 开始复制了，将 _path 路径下的两个 dex 移动到 path 路径
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    copy_if_not_exist(_path, path);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (v2) copy_if_not_exist(_path_legacy, path_legacy);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    check_access(path, <span style=color:#e6db74>&#34;dex path&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (v2) check_access(path_legacy, <span style=color:#e6db74>&#34;legacy dex path&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;info: starter begin</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 强制输出缓冲区的信息，就是为了快速输出上面的 printf 内容啦
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    fflush(stdout); 
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;info: starting server v3...</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    fflush(stdout);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 我们重点分析这个 start_service 函数，传入 SERVICE_CLASS_PATH 这个常量，值为 &#34;moe.shizuku.server.Starter&#34;，熟悉吗？这就是在应用层的主角啊，用于启动 ShizukuService 的 Java 类。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    start_server(path, SERVER_CLASS_PATH, token, SERVER_NAME, use_shell_context);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (v2) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;info: starting server v2 (legacy)...</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        fflush(stdout);
</span></span><span style=display:flex><span>        start_server(path_legacy, SERVER_CLASS_PATH_LEGACY, token, SERVER_NAME_LEGACY, false);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    exit_with_logcat(EXIT_SUCCESS);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// starter.cpp 结束
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>注释上已经大概地说了一遍，我们接下来看 start_service 函数，同样 start_service 也是 starter.cpp 中的一个函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>start_server</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>path, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>main_class, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>token,
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>nice_name, <span style=color:#66d9ef>int</span> change_context) {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 省略了很多内容，详细可自己去看看 Shizuku 的源码 */</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span> buf[<span style=color:#ae81ff>128</span>], class_path[PATH_MAX];
</span></span><span style=display:flex><span>    sprintf(buf, <span style=color:#e6db74>&#34;--nice-name=%s&#34;</span>, nice_name);
</span></span><span style=display:flex><span>    setClasspathEnv(path);
</span></span><span style=display:flex><span>    snprintf(class_path, PATH_MAX, <span style=color:#e6db74>&#34;-Djava.class.path=%s&#34;</span>, path);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>appProcessArgs[] <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// app_process 是 Android 里专门用来启动 Java 程序的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>const_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span> <span style=color:#f92672>*&gt;</span>(<span style=color:#e6db74>&#34;/system/bin/app_process&#34;</span>),
</span></span><span style=display:flex><span>        class_path,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span> <span style=color:#f92672>*&gt;</span>(<span style=color:#e6db74>&#34;/system/bin&#34;</span>),
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span> <span style=color:#f92672>*&gt;</span>(buf),
</span></span><span style=display:flex><span>        <span style=color:#75715e>// main_class 值为 &#34;moe.shizuku.server.Starter&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>const_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span> <span style=color:#f92672>*&gt;</span>(main_class),
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span> <span style=color:#f92672>*&gt;</span>(token),
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>nullptr</span>
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 调用 app_process 去运行 main_class
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (execvp(appProcessArgs[<span style=color:#ae81ff>0</span>], appProcessArgs)) {
</span></span><span style=display:flex><span>        exit_with_logcat(EXIT_FATAL_APP_PROCESS);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>到这里我们的分析已经差不多了。</p><p>我们再仔细说说 app_process 的内容：</p><p>调用 app_process 的话，你需要在参数中提供 dex 文件，同时必须要使 dex 文件有执行权限</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>app_process -Djava.class.path=dex文件名 dex所处的目录路径 <span style=color:#960050;background-color:#1e0010>你要启动的</span> Java <span style=color:#960050;background-color:#1e0010>类（有类名和包名）</span>
</span></span></code></pre></div><p>我找来了一个参数列表：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>vm-options – VM 选项
</span></span><span style=display:flex><span>cmd-dir –父目录 <span style=color:#f92672>(</span>/system/bin<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>options –运行的参数 :
</span></span><span style=display:flex><span>    –zygote
</span></span><span style=display:flex><span>    –start-system-server
</span></span><span style=display:flex><span>    –application <span style=color:#f92672>(</span>api&gt;<span style=color:#f92672>=</span>14<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    –nice-name<span style=color:#f92672>=</span>nice_proc_name <span style=color:#f92672>(</span>api&gt;<span style=color:#f92672>=</span>14<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>start-class-name –包含main方法的主类  <span style=color:#f92672>(</span>com.android.commands.am.Am<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>main-options –启动时候传递到main方法中的参数
</span></span></code></pre></div><h1 id=小总结>小总结<a hidden class=anchor aria-hidden=true href=#小总结>#</a></h1><p>用户通过输入一条 adb 命令去执行 start.sh 文件，start.sh 文件会执行 ShizukuManager 早已准备好的 so 文件。在 so 文件中经过一大堆操作，会通过 app_process 运行 Starter 类的 main 方法，而 Starter 这个 Java 类的 main 方法会直接 new 一个 ShizukuService 使它跑起来。</p><p>看了一上午的代码，翘了一上午的在铛铛的网络课。</p><p>尼玛，都延长假期了和上个屎的网络课。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://moonlab.top/tags/android/>Android</a></li></ul></footer><script src=https://comment.moonlab.top/moontalk.js></script><div id=container></div><script>(new MoonTalk).init({page_key:window.location.href,server:"https:///comment.moonlab.top",element:"#container"})</script></article></main><aside class=rightbar><div class=rightbar-categories><h3>分类</h3><ul class=rightbar-categories-first-list><li><a href=https://moonlab.top/categories/programming/>Programming</a> (16)<ul class=rightbar-categories-sec-list><li><a href=/tags/embeded>Embeded</a></li><li><a href=/tags/golang>golang</a></li><li><a href=/tags/linux>Linux</a></li><li><a href=/tags/android>Android</a></li></ul></li><li><a href=https://moonlab.top/categories/reverse/>Reverse</a> (1)<ul class=rightbar-categories-sec-list><li><a href=/tags/javascript>JavaScript</a></li></ul></li><li><a href=https://moonlab.top/categories/%E5%85%B6%E4%BB%96/>其他</a> (5)<ul class=rightbar-categories-sec-list><li><a href=/tags/blog>blog</a></li></ul></li><li><a href=https://moonlab.top/categories/%E7%AE%97%E6%B3%95/>算法</a> (4)<ul class=rightbar-categories-sec-list></ul></li></ul></div></aside></div><footer class=footer><img id=mooncounter-img style="margin:0 auto;margin-bottom:6px"></img>
<script src="//counter.moonlab.top/img?name=https://moonlab.top/"></script><span>&copy; 2025 <a href=https://moonlab.top/>MoonLab</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span><a href=https://www.travellings.cn/go.html rel=noopener target=_blank><img style=height:27px alt=travelling src=https://www.travellings.cn/assets/logo.svg></a></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>