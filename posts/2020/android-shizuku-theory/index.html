<!doctype html><html lang=cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Android Shizuku源码分析 | MoonLab</title>
<meta name=keywords content="Android"><meta name=description content="本文分析了 Shizuku 的源码，介绍了其如何通过 Binder 实现与 Android 系统服务的交互。Shizuku 应用引导用户以 root 或 adb 方式运行服务进程，利用 ShizukuBinderWrapper 进行系统隐藏 API 的调用。文章详细探讨了 ShizukuBinderWrapper 的构造、transact 方法及其与 IShizukuService 的通信过程，最后简要提及 ShizukuService 的启动流程。作者计划进一步深入分析 Shizuku 的启动机制。"><meta name=author content="LingC"><link rel=canonical href=https://moonlab.top/posts/2020/android-shizuku-theory/><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"],["$","$"]]},loader:{load:["ui/safe"]}}</script><link crossorigin=anonymous href=/assets/css/stylesheet.1ff5a7b3bb4a96bf1747dfa25e8031167d4537d7ae4b78fac2b752886047a06e.css rel="preload stylesheet" as=style><link rel=icon href=/moon.svg type=image/svg+xml><link rel=icon type=image/png sizes=16x16 href=https://moonlab.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://moonlab.top/favicon-32x32.png><link rel=apple-touch-icon href=https://moonlab.top/apple-touch-icon.png><link rel=mask-icon href=https://moonlab.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=cn href=https://moonlab.top/posts/2020/android-shizuku-theory/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Android Shizuku源码分析"><meta property="og:description" content="本文分析了 Shizuku 的源码，介绍了其如何通过 Binder 实现与 Android 系统服务的交互。Shizuku 应用引导用户以 root 或 adb 方式运行服务进程，利用 ShizukuBinderWrapper 进行系统隐藏 API 的调用。文章详细探讨了 ShizukuBinderWrapper 的构造、transact 方法及其与 IShizukuService 的通信过程，最后简要提及 ShizukuService 的启动流程。作者计划进一步深入分析 Shizuku 的启动机制。"><meta property="og:type" content="article"><meta property="og:url" content="https://moonlab.top/posts/2020/android-shizuku-theory/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-02-02T19:24:10+00:00"><meta property="article:modified_time" content="2020-02-02T19:24:10+00:00"><meta property="og:site_name" content="MoonLab"><meta name=twitter:card content="summary"><meta name=twitter:title content="Android Shizuku源码分析"><meta name=twitter:description content="本文分析了 Shizuku 的源码，介绍了其如何通过 Binder 实现与 Android 系统服务的交互。Shizuku 应用引导用户以 root 或 adb 方式运行服务进程，利用 ShizukuBinderWrapper 进行系统隐藏 API 的调用。文章详细探讨了 ShizukuBinderWrapper 的构造、transact 方法及其与 IShizukuService 的通信过程，最后简要提及 ShizukuService 的启动流程。作者计划进一步深入分析 Shizuku 的启动机制。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://moonlab.top/posts/"},{"@type":"ListItem","position":2,"name":"Android Shizuku源码分析","item":"https://moonlab.top/posts/2020/android-shizuku-theory/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Android Shizuku源码分析","name":"Android Shizuku源码分析","description":"本文分析了 Shizuku 的源码，介绍了其如何通过 Binder 实现与 Android 系统服务的交互。Shizuku 应用引导用户以 root 或 adb 方式运行服务进程，利用 ShizukuBinderWrapper 进行系统隐藏 API 的调用。文章详细探讨了 ShizukuBinderWrapper 的构造、transact 方法及其与 IShizukuService 的通信过程，最后简要提及 ShizukuService 的启动流程。作者计划进一步深入分析 Shizuku 的启动机制。","keywords":["Android"],"articleBody":"前言 上一篇文章我使用了 Shizuku 去调用系统API：文章链接\n这次就来看看 Shizuku 的源码是怎么写的。\n最开始我用 Notepad++ 看，最后还是用 as 看源码好点吧。\n官方文档\n酷安下载 ShizukuManager\nWatch it on GitHub\nShizuku 是什么？ Shizuku app 会引导用户使用 root 或是 adb 方式运行一个进程（Shizuku 服务进程）。\n应用进程启动时 Shizuku 服务进程发送 binder 至应用进程 应用通过该 binder 与 Shizuku 服务进程交互，Shizuku 服务进程通过 binder 与 system server 交互 正文 ShizukuBinderWrapper 首先我们看，在开发时调用 Shizuku 的代码：\nprivate static final IPackageManager PACKAGE_MANAGER = IPackageManager.Stub.asInterface(new ShizukuBinderWrapper(SystemServiceHelper.getSystemService(\"package\"))); 它使我们能随意调用 Android 系统中 IPackageManager 内的方法，也就是系统隐藏的API（有 @hide 标签的方法）\n我们可以看到 ShizukuBinderWrapper 的构造方法内传入了一个 SystemServiceHelper#getSystemService 方法的返回值。\nprivate static Map\u003cString, IBinder\u003e systemServiceCache = new HashMap\u003c\u003e(); public static IBinder getSystemService(@NonNull String name) { IBinder binder = systemServiceCache.get(name); if (binder == null) { binder = ServiceManager.getService(name); systemServiceCache.put(name, binder); } return binder; } getSystemService 方法先查询了一下缓存，如果没有缓存就调用 ServiceManager 的 getService 方法。这个本地的 ServiceManager 是在 android.os 包下：\npackage android.os; public class ServiceManager { public static IBinder getService(String name) { throw new UnsupportedOperationException(); } } getService 方法会根据 name 参数返回一个 IBinder 接口，我们可以查一下 Android 源码中的 ServiceManager 类：\npublic final class ServiceManager { /** * Returns a reference to a service with the given name. * * @param name the name of the service to get * @return a reference to the service, or null if the service doesn't exist */ public static IBinder getService(String name) { try { IBinder service = sCache.get(name); if (service != null) { return service; } else { return Binder.allowBlocking(rawGetService(name)); } } catch (RemoteException e) { Log.e(TAG, \"error in getService\", e); } return null; } } 其中 getService 不是 hide 方法可以直接调用。\n我们看看 ShizukuBinderWrapper 的构造参数：\nprivate IBinder original; // original 是 ServiceManager.getService 返回的 IBinder public ShizukuBinderWrapper(@NonNull IBinder original) { // 使用 requireNonNull 方法判断是否为 null，如果为 null 抛出空指针异常。 this.original = Objects.requireNonNull(original); } 这个构造参数对 original 进行了赋值，这是一个 IBinder。\n我们将这个 ShizukuBinderWrapper 传入Binder 的 asInterface 就能获得适用于客户端的 Binder 随意调用 IPackageiManager 内的方法，其中我在本地写的 IPackageManager 只是个空壳接口，只继承了 IInterface 声明了需要的方法：\npackage android.content.pm; // 与 Android 系统内的 IPackageManager 在同一个包下 import android.os.Binder; import android.os.IBinder; import android.os.IInterface; import android.os.RemoteException; public interface IPackageManager extends IInterface { // 我只需要这个方法，所以只声明这个方法来调用 ParceledListSlice\u003cPackageInfo\u003e getInstalledPackages(int flags, int userId) throws RemoteException; abstract class Stub extends Binder implements IPackageManager { public static IPackageManager asInterface(IBinder obj) { throw new UnsupportedOperationException(); } } } 我们查看 ShizukuBinderWrapper 的源码， ShizukuBinderWrapper 本身就实现了 IBinder 接口，所以可以直接作为上述 asInterface 方法的参数。\n这是 ShizukuBinderWrapper 中的 transact 方法的重写：\n/* ShizukuBinderWrapper#transact */ @Override public boolean transact(int code, @NonNull Parcel data, @Nullable Parcel reply, int flags) throws RemoteException { Parcel newData = Parcel.obtain(); try { // 使用 writeInterfaceToken 写入 ShizukuApiConstants.BINDER_DESCRIPTOR，用于后面服务端的判断 newData.writeInterfaceToken(ShizukuApiConstants.BINDER_DESCRIPTOR); // 写入了 original 这个 Binder newData.writeStrongBinder(original); newData.writeInt(code); newData.appendFrom(data, 0, data.dataSize()); ShizukuService.transactRemote(newData, reply, flags); } finally { newData.recycle(); } return true; } 我们都知道，在 aidl 中我们调用 Binder 的方法时实际上都调用了这个 transact 方法。\n例如：\nprivate static final IPackageManager PACKAGE_MANAGER = IPackageManager.Stub.asInterface(new ShizukuBinderWrapper(SystemServiceHelper.getSystemService(\"package\"))); ParceledListSlice\u003cPackageInfo\u003e listSlice = PACKAGE_MANAGER.getInstalledPackages(flags, userId); 这里我调用 getInstalledPackages 方法时，方法的内部实际上就调用了上面 ShizukuBinderWrapper 这个 Binder 的 transact 方法。在调用 getInstalledPackages 这个系统方法时，它内部就把我们调用系统方法所传入的参数写入了 data 中再传入这个 ShizukuBinderWrapper 的 transact 方法。\nShizukuBinderWrapper 的 transact 方法又把 data 和 reply 传入了 ShizukuService 的 transactRemote 下，这个 ShizukuService 是一个普通的类里面有一些静态变量和方法。\npackage moe.shizuku.api; /* ShizukuService#transactRemote */ public static void transactRemote(@NonNull Parcel data, @Nullable Parcel reply, int flags) throws RemoteException { // 调用 ShizukuService 的 requireService 方法 requireService().asBinder().transact(ShizukuApiConstants.BINDER_TRANSACTION_transact, data, reply, flags); } 我们可以看到，这个方法由调用了 requireService 方法取得了 Binder 再调用 Binder 的 transact 方法与服务端通信 ，再看看 requireService 方法：\nprivate static IShizukuService requireService() { if (getService() == null) { throw new IllegalStateException(\"Binder haven't received, check Shizuku and your code.\"); } return getService(); } 没什么好解释，继续看 getService 方法。\n/* ShizukuService */ private static IShizukuService sService; public static void setBinder(IBinder binder) { sService = IShizukuService.Stub.asInterface(binder); } private static IShizukuService getService() { return sService; } 这个 getService 静态方法会返回一个 IShizukuService 类型的 mService，而这个 mService 是由 setBinder 设置的，那么是谁调用了这个 ShizukuService.setBinder 方法来设置 mService ？我们先不管它。\nIShizukuService 我们再注意一下这个 IShizukuService：\n/* IShizukuService.aidl */ package moe.shizuku.server; import moe.shizuku.server.IRemoteProcess; interface IShizukuService { int getVersion() = 2; int getUid() = 3; int checkPermission(String permission) = 4; String getToken() = 5; boolean setPidToken(in String token) = 6; IRemoteProcess newProcess(in String[] cmd, in String[] env, in String dir) = 7; String getSELinuxContext() = 8; } 这个 AIDL 的作用是让我们开发的应用与 Shhizuku 的系统进程进行 Binder 通信。\n我们之前的 transactRemote 方法已经调用了它的 Binder 的 transact 方法开始联系服务端挂起客户端了。\n我们再看与 IShizukuService 相关的类：\npackage moe.shizuku.service public class ShizukuService extends IShizukuService.Stub { ... } 它不同于我们刚才看到的 moe.shizuku.api 下的 ShizukuService ，这是 moe.shizuku.service 下的 ShizukuService。是一个真真正正的服务端，和 Android 系统中的系统服务（例如AMS, PMS）类似没有直接继承 Service 类，而是继承自一个 Binder（后面我们再说）。\n接下来我们看它重写的 onTransact 方法：\n@Override public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException { if (code == ShizukuApiConstants.BINDER_TRANSACTION_transact) { data.enforceInterface(ShizukuApiConstants.BINDER_DESCRIPTOR); transactRemote(data, reply, flags); return true; } return super.onTransact(code, data, reply, flags); } 先用 enforceInterface 方法检查一下 Interface 是否与客户端的相同，再调用了 transactRemote 方法：\nprivate void transactRemote(Parcel data, Parcel reply, int flags) throws RemoteException { IBinder targetBinder = data.readStrongBinder(); int targetCode = data.readInt(); enforceCallingPermission(\"transactRemote\", true); targetBinder.getInterfaceDescriptor(), targetCode); Parcel newData = Parcel.obtain(); try { newData.appendFrom(data, data.dataPosition(), data.dataAvail()); } catch (Throwable tr) { LOGGER.w(tr, \"appendFrom\"); return; } try { long id = Binder.clearCallingIdentity(); // here targetBinder.transact(targetCode, newData, reply, flags); Binder.restoreCallingIdentity(id); } finally { newData.recycle(); } } 我们可以看到 targetBinder 其实就是我们之前用 SystemServiceHelper 的 getService 方法得到的 Binder，在调用它的 transact 方法，实现 Shizuku 服务与你想要通信的系统服务进行 Binder 通信，毕竟 Shizuku 服务已经通过 adb 或 root 成为了 dalao。\nShizukuService 的启动 上面我们看到了我们用到了 ShizukuService 去完成应用与系统服务的通信，而这个静态变量 mService 是通过 ShizukuService#setBinder 方法设置的：\npackage moe.shizuku.api; public class ShizukuService { private static IShizukuService sService; public static void setBinder(IBinder binder) { sService = IShizukuService.Stub.asInterface(binder); } } 首先，Starter 类中的 main 方法会启动 ShizukuService 服务：\npublic static void main(String[] args) throws IOException, RemoteException, InterruptedException { fixFilesOwner(); waitServiceManager(); waitSystemService(\"package\"); waitSystemService(\"activity\"); waitSystemService(Context.USER_SERVICE); waitSystemService(Context.APP_OPS_SERVICE); checkManagerApp(); if (Build.VERSION.SDK_INT \u003e= 28) { disableHiddenApiBlacklist(); } LOGGER.i(\"server v3\"); Looper.prepare(); // 这是 moe.shizuku.service 包下的继承自 Binder 的 ShizukuService ShizukuService server = new ShizukuService(getToken(args)); server.sendBinderToManager(); server.sendBinderToClients(); Looper.loop(); LOGGER.i(\"server exit\"); System.exit(0); } 可以看到这里直接 new 了一个 ShizukuService 实例，这和一些系统服务启动方法类似。\n其中调用了 ShizukuService 的 sendBinderToClients 方法，这中间有一大堆 dalao 操作，我们不作详细关注，泥萌可自行阅读源码。\n最后会调用 ShuzikuService 的 sendBinderToUserApp 方法，略过了一些其他的代码：\nstatic void sendBinderToUserApp(Binder binder, String packageName, int userId) { ... Bundle extra = new Bundle(); extra.putParcelable(ShizukuApiConstants.EXTRA_BINDER, new BinderContainer(binder)); Bundle reply = IContentProviderHelper.call(provider, null, name, \"sendBinder\", null, extra); ... } 将 ShizukuService 这个 Binder 包装成一个 BinderContainer 类然后放入 Bundle 里。\n这个 IContentProviderHelper 的 call 方法会跨进程调用 ShizukuBinderReceiveProvider 这个 ContentProvider 的 call 方法：\n@Nullable @Override public final Bundle call(@NonNull String method, @Nullable String arg, @Nullable Bundle extras) { if (extras == null) return null; Bundle reply = new Bundle(); extras.setClassLoader(BinderContainer.class.getClassLoader()); switch (method) { case METHOD_SEND_BINDER: { if (ShizukuService.pingBinder()) { Log.i(\"ShizukuClient\", \"ShizukuBinderReceiveProvider started when already a binder alive\"); break; } BinderContainer container = extras.getParcelable(ShizukuApiConstants.EXTRA_BINDER); if (container != null \u0026\u0026 container.binder != null) { Log.i(\"ShizukuClient\", \"binder received\"); // 调用 ShizukuService 的 setBinder 静态方法将静态变量 mService 设置成之前在 app_process 进程启动的 ShizukuService 的 Binder ShizukuService.setBinder(container.binder); //noinspection ConstantConditions Intent intent = new Intent(ShizukuMultiProcessHelper.ACTION_BINDER_RECEIVED) .putExtra(ShizukuApiConstants.EXTRA_BINDER, container) .setPackage(getContext().getPackageName()); getContext().sendBroadcast(intent); } ... break; } ... } return reply; } 其中调用了 ShizukuService 的 setBinder 方法，将 IShuzukuService 传进去了。\n末语 实际上这只分析了一部分，关于 ShizukuService 具体的如何启动，这个 main 方法是怎么调用的，和关于 start.sh 的一些问题，或许有生之年我能水写出第二篇文章…\nShizuku 内还有好多 dalao操作，我都没有去看，只把重要的一部分写了下来。\n果然只有 dalao才能这样操作，我还是继续躺着吧。\nOrz\n2020-02-04：\n时隔两天，我又写出了第二篇文章啦：https://lcblog.cn/post/android-shizuku-theory2\n尝试具体分析 Starter 类是如何启动的。\n","wordCount":"1038","inLanguage":"cn","datePublished":"2020-02-02T19:24:10Z","dateModified":"2020-02-02T19:24:10Z","author":{"@type":"Person","name":"LingC"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://moonlab.top/posts/2020/android-shizuku-theory/"},"publisher":{"@type":"Organization","name":"MoonLab","logo":{"@type":"ImageObject","url":"https://moonlab.top/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://moonlab.top/ accesskey=h title="MoonLab (Alt + H)"><img src=/moon.svg alt aria-label=logo height=20>MoonLab</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://moonlab.top/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://moonlab.top/archives/ title=归档><span>归档</span></a></li><li><a href=https://moonlab.top/search/ title=搜索><span>搜索</span></a></li><li><a href=https://moonlab.top/about/ title=关于><span>关于</span></a></li><li><a href=https://www.travellings.cn/go.html target=_blank title=开往><span>开往</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><div class=body-layout><div class=leftbar></div><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Android Shizuku源码分析</h1><div class=post-meta><span title='2020-02-02 19:24:10 +0000 UTC'>February 2, 2020</span>&nbsp;·&nbsp;LingC</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a><ul><li><a href=#shizuku-%e6%98%af%e4%bb%80%e4%b9%88 aria-label="Shizuku 是什么？">Shizuku 是什么？</a></li></ul></li><li><a href=#%e6%ad%a3%e6%96%87 aria-label=正文>正文</a><ul><li><a href=#shizukubinderwrapper aria-label=ShizukuBinderWrapper>ShizukuBinderWrapper</a></li><li><a href=#ishizukuservice aria-label=IShizukuService>IShizukuService</a></li><li><a href=#shizukuservice-%e7%9a%84%e5%90%af%e5%8a%a8 aria-label="ShizukuService 的启动">ShizukuService 的启动</a></li></ul></li><li><a href=#%e6%9c%ab%e8%af%ad aria-label=末语>末语</a></li></ul></div></details></div><div class=post-summary><span class=bold-text>📦 由AI生成的摘要</span><br><span class=post-summary-main>本文分析了 Shizuku 的源码，介绍了其如何通过 Binder 实现与 Android 系统服务的交互。Shizuku 应用引导用户以 root 或 adb 方式运行服务进程，利用 ShizukuBinderWrapper 进行系统隐藏 API 的调用。文章详细探讨了 ShizukuBinderWrapper 的构造、transact 方法及其与 IShizukuService 的通信过程，最后简要提及 ShizukuService 的启动流程。作者计划进一步深入分析 Shizuku 的启动机制。</span></div><div class=post-content><h1 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h1><p>上一篇文章我使用了 Shizuku 去调用系统API：<a href=https://lcblog.cn/post/android-activity-monitor>文章链接</a></p><p>这次就来看看 Shizuku 的源码是怎么写的。</p><p>最开始我用 Notepad++ 看，最后还是用 as 看源码好点吧。</p><p><a href=https://shizuku.rikka.app/>官方文档</a></p><p><a href=https://www.coolapk.com/apk/moe.shizuku.privileged.api>酷安下载 ShizukuManager</a></p><p><a href=https://github.com/RikkaApps/Shizuku>Watch it on GitHub</a></p><h2 id=shizuku-是什么>Shizuku 是什么？<a hidden class=anchor aria-hidden=true href=#shizuku-是什么>#</a></h2><blockquote><p>Shizuku app 会引导用户使用 root 或是 adb 方式运行一个进程（Shizuku 服务进程）。</p><ol><li>应用进程启动时 Shizuku 服务进程发送 binder 至应用进程</li><li>应用通过该 binder 与 Shizuku 服务进程交互，Shizuku 服务进程通过 binder 与 system server 交互</li></ol></blockquote><h1 id=正文>正文<a hidden class=anchor aria-hidden=true href=#正文>#</a></h1><h2 id=shizukubinderwrapper>ShizukuBinderWrapper<a hidden class=anchor aria-hidden=true href=#shizukubinderwrapper>#</a></h2><p>首先我们看，在开发时调用 Shizuku 的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> IPackageManager PACKAGE_MANAGER <span style=color:#f92672>=</span> IPackageManager.<span style=color:#a6e22e>Stub</span>.<span style=color:#a6e22e>asInterface</span>(<span style=color:#66d9ef>new</span> ShizukuBinderWrapper(SystemServiceHelper.<span style=color:#a6e22e>getSystemService</span>(<span style=color:#e6db74>&#34;package&#34;</span>)));
</span></span></code></pre></div><p>它使我们能随意调用 Android 系统中 IPackageManager 内的方法，也就是系统隐藏的API（有 @hide 标签的方法）</p><p>我们可以看到 ShizukuBinderWrapper 的构造方法内传入了一个 SystemServiceHelper#getSystemService 方法的返回值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> Map<span style=color:#f92672>&lt;</span>String, IBinder<span style=color:#f92672>&gt;</span> systemServiceCache <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>(); 
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> IBinder <span style=color:#a6e22e>getSystemService</span>(<span style=color:#a6e22e>@NonNull</span> String name) {
</span></span><span style=display:flex><span>        IBinder binder <span style=color:#f92672>=</span> systemServiceCache.<span style=color:#a6e22e>get</span>(name);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (binder <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            binder <span style=color:#f92672>=</span> ServiceManager.<span style=color:#a6e22e>getService</span>(name);
</span></span><span style=display:flex><span>            systemServiceCache.<span style=color:#a6e22e>put</span>(name, binder);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> binder;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>getSystemService 方法先查询了一下缓存，如果没有缓存就调用 ServiceManager 的 getService 方法。这个本地的 ServiceManager 是在 android.os 包下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> android.os;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ServiceManager</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> IBinder <span style=color:#a6e22e>getService</span>(String name) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> UnsupportedOperationException();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>getService 方法会根据 name 参数返回一个 IBinder 接口，我们可以查一下 Android 源码中的 ServiceManager 类：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ServiceManager</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Returns a reference to a service with the given name.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     *
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param name the name of the service to get
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @return a reference to the service, or &lt;code&gt;null&lt;/code&gt; if the service doesn&#39;t exist
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> IBinder <span style=color:#a6e22e>getService</span>(String name) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            IBinder service <span style=color:#f92672>=</span> sCache.<span style=color:#a6e22e>get</span>(name);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (service <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> service;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> Binder.<span style=color:#a6e22e>allowBlocking</span>(rawGetService(name));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (RemoteException e) {
</span></span><span style=display:flex><span>            Log.<span style=color:#a6e22e>e</span>(TAG, <span style=color:#e6db74>&#34;error in getService&#34;</span>, e);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>其中 getService 不是 hide 方法可以直接调用。</p><p>我们看看 ShizukuBinderWrapper 的构造参数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span> <span style=color:#66d9ef>private</span> IBinder original;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// original 是 ServiceManager.getService 返回的 IBinder</span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>ShizukuBinderWrapper</span>(<span style=color:#a6e22e>@NonNull</span> IBinder original) {
</span></span><span style=display:flex><span>     <span style=color:#75715e>// 使用 requireNonNull 方法判断是否为 null，如果为 null 抛出空指针异常。</span>
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>original</span> <span style=color:#f92672>=</span> Objects.<span style=color:#a6e22e>requireNonNull</span>(original);
</span></span><span style=display:flex><span> }
</span></span></code></pre></div><p>这个构造参数对 original 进行了赋值，这是一个 IBinder。</p><p>我们将这个 ShizukuBinderWrapper 传入Binder 的 asInterface 就能获得适用于客户端的 Binder 随意调用 IPackageiManager 内的方法，其中我在本地写的 IPackageManager 只是个空壳接口，只继承了 IInterface 声明了需要的方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> android.content.pm;
</span></span><span style=display:flex><span><span style=color:#75715e>// 与 Android 系统内的 IPackageManager 在同一个包下</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> android.os.Binder;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> android.os.IBinder;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> android.os.IInterface;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> android.os.RemoteException;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IPackageManager</span> <span style=color:#66d9ef>extends</span> IInterface {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 我只需要这个方法，所以只声明这个方法来调用</span>
</span></span><span style=display:flex><span>    ParceledListSlice<span style=color:#f92672>&lt;</span>PackageInfo<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>getInstalledPackages</span>(<span style=color:#66d9ef>int</span> flags, <span style=color:#66d9ef>int</span> userId) <span style=color:#66d9ef>throws</span> RemoteException;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Stub</span> <span style=color:#66d9ef>extends</span> Binder <span style=color:#66d9ef>implements</span> IPackageManager {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> IPackageManager <span style=color:#a6e22e>asInterface</span>(IBinder obj) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> UnsupportedOperationException();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们查看 ShizukuBinderWrapper 的源码， ShizukuBinderWrapper 本身就实现了 IBinder 接口，所以可以直接作为上述 asInterface 方法的参数。</p><p>这是 ShizukuBinderWrapper 中的 transact 方法的重写：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>  <span style=color:#75715e>/* ShizukuBinderWrapper#transact */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>transact</span>(<span style=color:#66d9ef>int</span> code, <span style=color:#a6e22e>@NonNull</span> Parcel data, <span style=color:#a6e22e>@Nullable</span> Parcel reply, <span style=color:#66d9ef>int</span> flags) <span style=color:#66d9ef>throws</span> RemoteException {
</span></span><span style=display:flex><span>        Parcel newData <span style=color:#f92672>=</span> Parcel.<span style=color:#a6e22e>obtain</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 使用 writeInterfaceToken 写入 ShizukuApiConstants.BINDER_DESCRIPTOR，用于后面服务端的判断</span>
</span></span><span style=display:flex><span>            newData.<span style=color:#a6e22e>writeInterfaceToken</span>(ShizukuApiConstants.<span style=color:#a6e22e>BINDER_DESCRIPTOR</span>);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 写入了 original 这个 Binder</span>
</span></span><span style=display:flex><span>            newData.<span style=color:#a6e22e>writeStrongBinder</span>(original);
</span></span><span style=display:flex><span>            newData.<span style=color:#a6e22e>writeInt</span>(code);
</span></span><span style=display:flex><span>            newData.<span style=color:#a6e22e>appendFrom</span>(data, 0, data.<span style=color:#a6e22e>dataSize</span>());
</span></span><span style=display:flex><span>            ShizukuService.<span style=color:#a6e22e>transactRemote</span>(newData, reply, flags);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>            newData.<span style=color:#a6e22e>recycle</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>我们都知道，在 aidl 中我们调用 Binder 的方法时实际上都调用了这个 transact 方法。</p><p>例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> IPackageManager PACKAGE_MANAGER <span style=color:#f92672>=</span> IPackageManager.<span style=color:#a6e22e>Stub</span>.<span style=color:#a6e22e>asInterface</span>(<span style=color:#66d9ef>new</span> ShizukuBinderWrapper(SystemServiceHelper.<span style=color:#a6e22e>getSystemService</span>(<span style=color:#e6db74>&#34;package&#34;</span>)));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ParceledListSlice<span style=color:#f92672>&lt;</span>PackageInfo<span style=color:#f92672>&gt;</span> listSlice <span style=color:#f92672>=</span> PACKAGE_MANAGER.<span style=color:#a6e22e>getInstalledPackages</span>(flags, userId);
</span></span></code></pre></div><p>这里我调用 getInstalledPackages 方法时，方法的内部实际上就调用了上面 ShizukuBinderWrapper 这个 Binder 的 transact 方法。在调用 getInstalledPackages 这个系统方法时，它内部就把我们调用系统方法所传入的参数写入了 data 中再传入这个 ShizukuBinderWrapper 的 transact 方法。</p><p>ShizukuBinderWrapper 的 transact 方法又把 data 和 reply 传入了 ShizukuService 的 transactRemote 下，这个 ShizukuService 是一个普通的类里面有一些静态变量和方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> moe.shizuku.api;
</span></span><span style=display:flex><span><span style=color:#75715e>/* ShizukuService#transactRemote */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>transactRemote</span>(<span style=color:#a6e22e>@NonNull</span> Parcel data, <span style=color:#a6e22e>@Nullable</span> Parcel reply, <span style=color:#66d9ef>int</span> flags) <span style=color:#66d9ef>throws</span> RemoteException {
</span></span><span style=display:flex><span><span style=color:#75715e>// 调用 ShizukuService 的 requireService 方法</span>
</span></span><span style=display:flex><span>requireService().<span style=color:#a6e22e>asBinder</span>().<span style=color:#a6e22e>transact</span>(ShizukuApiConstants.<span style=color:#a6e22e>BINDER_TRANSACTION_transact</span>, data, reply, flags);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们可以看到，这个方法由调用了 requireService 方法取得了 Binder 再调用 Binder 的 transact 方法与服务端通信 ，再看看 requireService 方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> IShizukuService <span style=color:#a6e22e>requireService</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (getService() <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalStateException(<span style=color:#e6db74>&#34;Binder haven&#39;t received, check Shizuku and your code.&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> getService();
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>没什么好解释，继续看 getService 方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/* ShizukuService */</span> 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> IShizukuService sService;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setBinder</span>(IBinder binder) {
</span></span><span style=display:flex><span>        sService <span style=color:#f92672>=</span> IShizukuService.<span style=color:#a6e22e>Stub</span>.<span style=color:#a6e22e>asInterface</span>(binder);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> IShizukuService <span style=color:#a6e22e>getService</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> sService;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>这个 getService 静态方法会返回一个 IShizukuService 类型的 mService，而这个 mService 是由 setBinder 设置的，那么是谁调用了这个 ShizukuService.setBinder 方法来设置 mService ？我们先不管它。</p><h2 id=ishizukuservice>IShizukuService<a hidden class=anchor aria-hidden=true href=#ishizukuservice>#</a></h2><p>我们再注意一下这个 IShizukuService：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/* IShizukuService.aidl */</span>
</span></span><span style=display:flex><span><span style=color:#f92672>package</span> moe.shizuku.server;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> moe.shizuku.server.IRemoteProcess;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IShizukuService</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getVersion</span>() <span style=color:#f92672>=</span> 2;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getUid</span>() <span style=color:#f92672>=</span> 3;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>checkPermission</span>(String permission) <span style=color:#f92672>=</span> 4;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    String <span style=color:#a6e22e>getToken</span>() <span style=color:#f92672>=</span> 5;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>setPidToken</span>(in String token) <span style=color:#f92672>=</span> 6;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    IRemoteProcess <span style=color:#a6e22e>newProcess</span>(in String<span style=color:#f92672>[]</span> cmd, in String<span style=color:#f92672>[]</span> env, in String dir) <span style=color:#f92672>=</span> 7;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    String <span style=color:#a6e22e>getSELinuxContext</span>() <span style=color:#f92672>=</span> 8;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个 AIDL 的作用是让我们开发的应用与 Shhizuku 的系统进程进行 Binder 通信。</p><p>我们之前的 transactRemote 方法已经调用了它的 Binder 的 transact 方法开始联系服务端挂起客户端了。</p><p>我们再看与 IShizukuService 相关的类：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> moe.shizuku.service
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ShizukuService</span> <span style=color:#66d9ef>extends</span> IShizukuService.<span style=color:#a6e22e>Stub</span> {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>它不同于我们刚才看到的 moe.shizuku.api 下的 ShizukuService ，这是 moe.shizuku.service 下的 ShizukuService。是一个真真正正的服务端，和 Android 系统中的系统服务（例如AMS, PMS）类似没有直接继承 Service 类，而是继承自一个 Binder（后面我们再说）。</p><p>接下来我们看它重写的 onTransact 方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>onTransact</span>(<span style=color:#66d9ef>int</span> code, Parcel data, Parcel reply, <span style=color:#66d9ef>int</span> flags) <span style=color:#66d9ef>throws</span> RemoteException {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (code <span style=color:#f92672>==</span> ShizukuApiConstants.<span style=color:#a6e22e>BINDER_TRANSACTION_transact</span>) {
</span></span><span style=display:flex><span>            data.<span style=color:#a6e22e>enforceInterface</span>(ShizukuApiConstants.<span style=color:#a6e22e>BINDER_DESCRIPTOR</span>);
</span></span><span style=display:flex><span>            transactRemote(data, reply, flags);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>super</span>.<span style=color:#a6e22e>onTransact</span>(code, data, reply, flags);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>先用 enforceInterface 方法检查一下 Interface 是否与客户端的相同，再调用了 transactRemote 方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span> <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>transactRemote</span>(Parcel data, Parcel reply, <span style=color:#66d9ef>int</span> flags) <span style=color:#66d9ef>throws</span> RemoteException {
</span></span><span style=display:flex><span>        IBinder targetBinder <span style=color:#f92672>=</span> data.<span style=color:#a6e22e>readStrongBinder</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> targetCode <span style=color:#f92672>=</span> data.<span style=color:#a6e22e>readInt</span>();
</span></span><span style=display:flex><span>        enforceCallingPermission(<span style=color:#e6db74>&#34;transactRemote&#34;</span>, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>        targetBinder.<span style=color:#a6e22e>getInterfaceDescriptor</span>(), targetCode);
</span></span><span style=display:flex><span>        Parcel newData <span style=color:#f92672>=</span> Parcel.<span style=color:#a6e22e>obtain</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            newData.<span style=color:#a6e22e>appendFrom</span>(data, data.<span style=color:#a6e22e>dataPosition</span>(), data.<span style=color:#a6e22e>dataAvail</span>());
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Throwable tr) {
</span></span><span style=display:flex><span>            LOGGER.<span style=color:#a6e22e>w</span>(tr, <span style=color:#e6db74>&#34;appendFrom&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>long</span> id <span style=color:#f92672>=</span> Binder.<span style=color:#a6e22e>clearCallingIdentity</span>();
</span></span><span style=display:flex><span>            <span style=color:#75715e>// here</span>
</span></span><span style=display:flex><span>            targetBinder.<span style=color:#a6e22e>transact</span>(targetCode, newData, reply, flags);
</span></span><span style=display:flex><span>            Binder.<span style=color:#a6e22e>restoreCallingIdentity</span>(id);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>            newData.<span style=color:#a6e22e>recycle</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>我们可以看到 targetBinder 其实就是我们之前用 SystemServiceHelper 的 getService 方法得到的 Binder，在调用它的 transact 方法，实现 Shizuku 服务与你想要通信的系统服务进行 Binder 通信，毕竟 Shizuku 服务已经通过 adb 或 root 成为了 dalao。</p><h2 id=shizukuservice-的启动>ShizukuService 的启动<a hidden class=anchor aria-hidden=true href=#shizukuservice-的启动>#</a></h2><p>上面我们看到了我们用到了 ShizukuService 去完成应用与系统服务的通信，而这个静态变量 mService 是通过 ShizukuService#setBinder 方法设置的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> moe.shizuku.api;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ShizukuService</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> IShizukuService sService;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setBinder</span>(IBinder binder) {
</span></span><span style=display:flex><span>        sService <span style=color:#f92672>=</span> IShizukuService.<span style=color:#a6e22e>Stub</span>.<span style=color:#a6e22e>asInterface</span>(binder);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>首先，Starter 类中的 main 方法会启动 ShizukuService 服务：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span> <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) <span style=color:#66d9ef>throws</span> IOException, RemoteException, InterruptedException {
</span></span><span style=display:flex><span>        fixFilesOwner();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        waitServiceManager();
</span></span><span style=display:flex><span>        waitSystemService(<span style=color:#e6db74>&#34;package&#34;</span>);
</span></span><span style=display:flex><span>        waitSystemService(<span style=color:#e6db74>&#34;activity&#34;</span>);
</span></span><span style=display:flex><span>        waitSystemService(Context.<span style=color:#a6e22e>USER_SERVICE</span>);
</span></span><span style=display:flex><span>        waitSystemService(Context.<span style=color:#a6e22e>APP_OPS_SERVICE</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        checkManagerApp();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (Build.<span style=color:#a6e22e>VERSION</span>.<span style=color:#a6e22e>SDK_INT</span> <span style=color:#f92672>&gt;=</span> 28) {
</span></span><span style=display:flex><span>            disableHiddenApiBlacklist();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        LOGGER.<span style=color:#a6e22e>i</span>(<span style=color:#e6db74>&#34;server v3&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Looper.<span style=color:#a6e22e>prepare</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 这是 moe.shizuku.service 包下的继承自 Binder 的 ShizukuService</span>
</span></span><span style=display:flex><span>        ShizukuService server <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ShizukuService(getToken(args));
</span></span><span style=display:flex><span>        server.<span style=color:#a6e22e>sendBinderToManager</span>();
</span></span><span style=display:flex><span>        server.<span style=color:#a6e22e>sendBinderToClients</span>();
</span></span><span style=display:flex><span>        Looper.<span style=color:#a6e22e>loop</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        LOGGER.<span style=color:#a6e22e>i</span>(<span style=color:#e6db74>&#34;server exit&#34;</span>);
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>exit</span>(0);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>可以看到这里直接 new 了一个 ShizukuService 实例，这和一些系统服务启动方法类似。</p><p>其中调用了 ShizukuService 的 sendBinderToClients 方法，这中间有一大堆 dalao 操作，我们不作详细关注，泥萌可自行阅读源码。</p><p>最后会调用 ShuzikuService 的 sendBinderToUserApp 方法，略过了一些其他的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sendBinderToUserApp</span>(Binder binder, String packageName, <span style=color:#66d9ef>int</span> userId) {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>     Bundle extra <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Bundle();
</span></span><span style=display:flex><span>     extra.<span style=color:#a6e22e>putParcelable</span>(ShizukuApiConstants.<span style=color:#a6e22e>EXTRA_BINDER</span>, <span style=color:#66d9ef>new</span> BinderContainer(binder));
</span></span><span style=display:flex><span>     Bundle reply <span style=color:#f92672>=</span> IContentProviderHelper.<span style=color:#a6e22e>call</span>(provider, <span style=color:#66d9ef>null</span>, name, <span style=color:#e6db74>&#34;sendBinder&#34;</span>, <span style=color:#66d9ef>null</span>, extra);
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>将 ShizukuService 这个 Binder 包装成一个 BinderContainer 类然后放入 Bundle 里。</p><p>这个 IContentProviderHelper 的 call 方法会跨进程调用 ShizukuBinderReceiveProvider 这个 ContentProvider 的 call 方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span> <span style=color:#a6e22e>@Nullable</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> Bundle <span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>@NonNull</span> String method, <span style=color:#a6e22e>@Nullable</span> String arg, <span style=color:#a6e22e>@Nullable</span> Bundle extras) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (extras <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        Bundle reply <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Bundle();
</span></span><span style=display:flex><span>        extras.<span style=color:#a6e22e>setClassLoader</span>(BinderContainer.<span style=color:#a6e22e>class</span>.<span style=color:#a6e22e>getClassLoader</span>());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>switch</span> (method) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>case</span> METHOD_SEND_BINDER: {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (ShizukuService.<span style=color:#a6e22e>pingBinder</span>()) {
</span></span><span style=display:flex><span>                    Log.<span style=color:#a6e22e>i</span>(<span style=color:#e6db74>&#34;ShizukuClient&#34;</span>, <span style=color:#e6db74>&#34;ShizukuBinderReceiveProvider started when already a binder alive&#34;</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                BinderContainer container <span style=color:#f92672>=</span> extras.<span style=color:#a6e22e>getParcelable</span>(ShizukuApiConstants.<span style=color:#a6e22e>EXTRA_BINDER</span>);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (container <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> container.<span style=color:#a6e22e>binder</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                    Log.<span style=color:#a6e22e>i</span>(<span style=color:#e6db74>&#34;ShizukuClient&#34;</span>, <span style=color:#e6db74>&#34;binder received&#34;</span>);
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 调用 ShizukuService 的 setBinder 静态方法将静态变量 mService 设置成之前在 app_process 进程启动的 ShizukuService 的 Binder</span>
</span></span><span style=display:flex><span>                    ShizukuService.<span style=color:#a6e22e>setBinder</span>(container.<span style=color:#a6e22e>binder</span>);
</span></span><span style=display:flex><span>                    <span style=color:#75715e>//noinspection ConstantConditions</span>
</span></span><span style=display:flex><span>                    Intent intent <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Intent(ShizukuMultiProcessHelper.<span style=color:#a6e22e>ACTION_BINDER_RECEIVED</span>)
</span></span><span style=display:flex><span>                            .<span style=color:#a6e22e>putExtra</span>(ShizukuApiConstants.<span style=color:#a6e22e>EXTRA_BINDER</span>, container)
</span></span><span style=display:flex><span>                            .<span style=color:#a6e22e>setPackage</span>(getContext().<span style=color:#a6e22e>getPackageName</span>());
</span></span><span style=display:flex><span>                    getContext().<span style=color:#a6e22e>sendBroadcast</span>(intent);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                ...
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            ...
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> reply;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>其中调用了 ShizukuService 的 setBinder 方法，将 IShuzukuService 传进去了。</p><h1 id=末语>末语<a hidden class=anchor aria-hidden=true href=#末语>#</a></h1><p>实际上这只分析了一部分，关于 ShizukuService 具体的如何启动，这个 main 方法是怎么调用的，和关于 start.sh 的一些问题，或许有生之年我能<del>水</del>写出第二篇文章&mldr;</p><p>Shizuku 内还有好多 dalao操作，我都没有去看，只把重要的一部分写了下来。</p><p>果然只有 dalao才能这样操作，我还是继续躺着吧。</p><p>Orz</p><hr><p>2020-02-04：</p><p>时隔两天，我又写出了第二篇文章啦：https://lcblog.cn/post/android-shizuku-theory2</p><p>尝试具体分析 Starter 类是如何启动的。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://moonlab.top/tags/android/>Android</a></li></ul></footer><script src=https://comment.moonlab.top/moontalk.js></script><div id=container></div><script>(new MoonTalk).init({page_key:window.location.href,server:"https:///comment.moonlab.top",element:"#container"})</script></article></main><aside class=rightbar><div class=rightbar-categories><h3>分类</h3><ul class=rightbar-categories-first-list><li><a href=https://moonlab.top/categories/programming/>Programming</a> (16)<ul class=rightbar-categories-sec-list><li><a href=/tags/embeded>Embeded</a></li><li><a href=/tags/golang>golang</a></li><li><a href=/tags/linux>Linux</a></li><li><a href=/tags/android>Android</a></li></ul></li><li><a href=https://moonlab.top/categories/reverse/>Reverse</a> (1)<ul class=rightbar-categories-sec-list><li><a href=/tags/javascript>JavaScript</a></li></ul></li><li><a href=https://moonlab.top/categories/%E5%85%B6%E4%BB%96/>其他</a> (5)<ul class=rightbar-categories-sec-list><li><a href=/tags/blog>blog</a></li></ul></li><li><a href=https://moonlab.top/categories/%E7%AE%97%E6%B3%95/>算法</a> (4)<ul class=rightbar-categories-sec-list></ul></li></ul></div></aside></div><footer class=footer><img id=mooncounter-img style="margin:0 auto;margin-bottom:6px"></img>
<script src="//counter.moonlab.top/img?name=https://moonlab.top/"></script><span>&copy; 2025 <a href=https://moonlab.top/>MoonLab</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span><a href=https://www.travellings.cn/go.html rel=noopener target=_blank><img style=height:27px alt=travelling src=https://www.travellings.cn/assets/logo.svg></a></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>