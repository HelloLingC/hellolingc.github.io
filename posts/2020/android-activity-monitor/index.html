<!doctype html><html lang=cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Android 监听第三方Activity的一举一动 | MoonLab</title>
<meta name=keywords content="Android"><meta name=description content="这篇文章主要记录了作者在2019年初的个人感受和一些技术探索。作者回顾了过去一年的经历，感到没有太多进展，并提到冬季的天气和国内的传染病情况。尽管在家中待得久了，作者也提到了一些娱乐活动，比如观看动画和春晚，但整体上对新番的期待逐渐减弱。在技术方面，作者分享了在Android开发中监听Activity启动的需求，探讨了几种方法来获取Activity的类名。首先，作者提到使用ActivityManager的getRunningTasks方法，但由于权限限制，这种方法不可行。接着，作者提到UsageStatsManager只能获取应用包名，而无法获取Activity类名。最终，作者发现了IActivityController接口，并通过使用Shizuku工具来调用系统API，从而实现了监听Activity启动的功能。总结来说，文章结合了个人生活感受与技术探索，展示了作者在面对生活和技术挑战时的思考与解决方案。"><meta name=author content="LingC"><link rel=canonical href=https://moonlab.top/posts/2020/android-activity-monitor/><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"],["$","$"]]},loader:{load:["ui/safe"]}}</script><link crossorigin=anonymous href=/assets/css/stylesheet.1ff5a7b3bb4a96bf1747dfa25e8031167d4537d7ae4b78fac2b752886047a06e.css rel="preload stylesheet" as=style><link rel=icon href=/moon.svg type=image/svg+xml><link rel=icon type=image/png sizes=16x16 href=https://moonlab.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://moonlab.top/favicon-32x32.png><link rel=apple-touch-icon href=https://moonlab.top/apple-touch-icon.png><link rel=mask-icon href=https://moonlab.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=cn href=https://moonlab.top/posts/2020/android-activity-monitor/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Android 监听第三方Activity的一举一动"><meta property="og:description" content="这篇文章主要记录了作者在2019年初的个人感受和一些技术探索。作者回顾了过去一年的经历，感到没有太多进展，并提到冬季的天气和国内的传染病情况。尽管在家中待得久了，作者也提到了一些娱乐活动，比如观看动画和春晚，但整体上对新番的期待逐渐减弱。在技术方面，作者分享了在Android开发中监听Activity启动的需求，探讨了几种方法来获取Activity的类名。首先，作者提到使用ActivityManager的getRunningTasks方法，但由于权限限制，这种方法不可行。接着，作者提到UsageStatsManager只能获取应用包名，而无法获取Activity类名。最终，作者发现了IActivityController接口，并通过使用Shizuku工具来调用系统API，从而实现了监听Activity启动的功能。总结来说，文章结合了个人生活感受与技术探索，展示了作者在面对生活和技术挑战时的思考与解决方案。"><meta property="og:type" content="article"><meta property="og:url" content="https://moonlab.top/posts/2020/android-activity-monitor/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-02-01T18:39:25+00:00"><meta property="article:modified_time" content="2020-02-01T18:39:25+00:00"><meta property="og:site_name" content="MoonLab"><meta name=twitter:card content="summary"><meta name=twitter:title content="Android 监听第三方Activity的一举一动"><meta name=twitter:description content="这篇文章主要记录了作者在2019年初的个人感受和一些技术探索。作者回顾了过去一年的经历，感到没有太多进展，并提到冬季的天气和国内的传染病情况。尽管在家中待得久了，作者也提到了一些娱乐活动，比如观看动画和春晚，但整体上对新番的期待逐渐减弱。在技术方面，作者分享了在Android开发中监听Activity启动的需求，探讨了几种方法来获取Activity的类名。首先，作者提到使用ActivityManager的getRunningTasks方法，但由于权限限制，这种方法不可行。接着，作者提到UsageStatsManager只能获取应用包名，而无法获取Activity类名。最终，作者发现了IActivityController接口，并通过使用Shizuku工具来调用系统API，从而实现了监听Activity启动的功能。总结来说，文章结合了个人生活感受与技术探索，展示了作者在面对生活和技术挑战时的思考与解决方案。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://moonlab.top/posts/"},{"@type":"ListItem","position":2,"name":"Android 监听第三方Activity的一举一动","item":"https://moonlab.top/posts/2020/android-activity-monitor/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Android 监听第三方Activity的一举一动","name":"Android 监听第三方Activity的一举一动","description":"这篇文章主要记录了作者在2019年初的个人感受和一些技术探索。作者回顾了过去一年的经历，感到没有太多进展，并提到冬季的天气和国内的传染病情况。尽管在家中待得久了，作者也提到了一些娱乐活动，比如观看动画和春晚，但整体上对新番的期待逐渐减弱。在技术方面，作者分享了在Android开发中监听Activity启动的需求，探讨了几种方法来获取Activity的类名。首先，作者提到使用ActivityManager的getRunningTasks方法，但由于权限限制，这种方法不可行。接着，作者提到UsageStatsManager只能获取应用包名，而无法获取Activity类名。最终，作者发现了IActivityController接口，并通过使用Shizuku工具来调用系统API，从而实现了监听Activity启动的功能。总结来说，文章结合了个人生活感受与技术探索，展示了作者在面对生活和技术挑战时的思考与解决方案。","keywords":["Android"],"articleBody":"前言 距离上一次更新也已经是六个月前了。感觉2019年过得真不咋样，什么也没干成吧，没有什么进步。\n不知不觉又是新的一年，2019是去年，2018就成了前年了。\n这个冬天我们这都没怎么下过雪，积雪的话我知记得有一次，融化得还很快。\n国内也出现了传染病，迄今为止有五千多人中枪了吧。现在也不让出去，亲戚也都没有拜完，现在天天在家窝。（不过好处就是不用上学啦）。\n今年的央视春晚也没有看，bilibili还搞了拜年祭，拜年祭真的是一年比一年棒了，可惜我也没兴趣看。\n最近在补魔法少女小圆，看得很慢。1月新番也没啥期待的，只有一部喜欢的：某科学电池炮T，毕竟是我的入坑番。还有一部是异度入侵，我不太喜欢目前的剧情，唯一喜欢的就只有OP了。\n哦其实还有Acfun独播的达尔文游戏，也还可以~~（因为我喜欢女主的性格）~~\n总结：一月新番喜欢的只有一部番和一首歌，没了。\n感觉越来越没意思了，也可能是我心态的变化，现在我都一直在看以前的番，新番我已经没啥可期待的了。\n这篇文章磨磨唧唧花费了三天，我已经把魔法少女小圆TV版看完了，太特喵好看了，还有剧场版和外传又够我看一阵子了。\n好多人都说“致郁”，其实我觉得还可以啊并不怎么致郁，相反还有些治愈（迫真脸）。\n[TOC]\n正文 回归正题，我在开发的过程中有一个小需求：需要监听每一个Activity的启动，并且需要获取Activity的ClassName。\n我这种菜鸡只能先求助百度：Android 监听第三方Activity\n方法1 首先百度到的第一个方法是搞一个Service，然后在一个循环里一直获取栈顶的Activity。\nemmmmmm….\nList\u003cActivityManager.RunningTaskInfo\u003e runningTasks = am.getRunningTasks(1); ActivityManager.RunningTaskInfo runningTaskInfo = runningTasks.get(0); 这个办法肯定是不行哒，Google早已对getRunningTasks方法严加管制，需要android.permission.GET_TOP_ACTIVITY_INFO权限，但是这个权限必须要系统app才能申请。\n但或许能用shell指令 ps 来获取栈顶的 Activity，虽然我没试过。\n方法2 (???) 第二个方法是使用 UsageStatsManager，也就是应用使用情况的一个功能。\n但是只能得到应用的包名，而不是Activity的类名。\n方法3 在我百度的时候我注意到了一个接口：IActivityController和一个方法：setActivityController。\n啊，决定了，就是你啦！\n我开始了解有关IActivityController的详细内容。\n我还发现了一个比AndroidXref稍微更友好的Android源码在线查看网站：https://www.androidos.net.cn/\n本来setActivityController这个方法是在ActivityManagerNative中的，但是在Android API 26的时候似乎被遗弃了，取而代之的是IActivityManager中的setActivityController。\n在之前，启动Activity的是ActivityManagerNative,getDefault()内的startActivity方法，而ActivityManagerService继承自ActivityManagerNative，ActivityManagerNative又继承自Binder并实现iActivityManager，AMS是IActivityManager的具体实现。\nIInterface, Stub, Proxy 三个类是分离的，分别是 IActivityManager，ActivityManagerNative (extends Binder) 和 ActivityManagerProxy。\n而现在（API 26+），AMS直接继承了 IActivityManager的内部类 Stub：\n这时候 Android 源码已经有了 IActivityManager.aidl，ActivityManagerNative 这个类被弃用了\npublic class ActivityManagerService extends IActivityManager.Stub implements Watchdog.Monitor, BatteryStatsImpl.BatteryCallback { ... } 那么自然而然，setIActivityController 这个方法是在 IActivityManager.aidl 内定义的，\n而 IActivityController 是一个在 Binder 中的回调接口，可以直接下载 IActivityController.aidl 放在 android.app 这个包下。要与 Android 系统源码的位置一致。\n但是该怎么调用 系统API 呢？除非我们的应用得在系统进程。\n这时候我在酷安看到了一个叫做 Shizuku 的玩意：官方文档\n它可以帮助我们快速使用 系统API，用户只需用 adb 或者 root 激活 Shizuku，看看官方文档的解释：\nShizuku 做法 Shizuku app 会引导用户使用 root 或是 adb 方式运行一个进程（Shizuku 服务进程）。\n应用进程启动时 Shizuku 服务进程发送 binder 至应用进程 应用通过该 binder 与 Shizuku 服务进程交互，Shizuku 服务进程通过 binder 与 system server 交互 Shizuku 的优点在于：\n极小额外时间及性能消耗 与直接调用 API 体验几乎一致（应用开发者只许添加少量代码） 导入 Shizuku 的开源库，先在 android.app 包内创建一个同名文件：!ActivityManager.java\n假装他是 IActivityManager.aidl 自动生成的一个类（我们无需在下载 IActivityManager.aidl 放在项目里）。\npackage android.app; import android.os.Binder; import android.os.IBinder; import android.os.IInterface; /* 我们自己创建的 IActivityManager */ public interface IActivityManager extends IInterface { void setActivityController(IActivityController watcher, boolean imAMonkey); abstract class Stub extends Binder implements IActivityManager { public static IActivityManager asInterface(IBinder obj) { throw new UnsupportedOperationException(); } } } 结构和 aidl 自动生成的类没什么两样，就是只把关键的方法写出来。\n注意哦，这个 Stub 是一个抽象类！asInterface 方法并没有具体的实现。\n之后我们再：\nprivate static final IActivityManager ACTIVITY_MANAGER = IActivityManager.Stub.asInterface(new ShizukuBinderWrapper(SystemServiceHelper.getSystemService(\"activity\"))); public static void setActivityController(IActivityController activityController) { if (!ShizukuService.pingBinder()) { return; } ACTIVITY_MANAGER.setActivityController(activityController, true); } 这样我们就能直接调用 setActivityController 方法了，然后在重写 IActivityController.Stub 内的回调方法就行了。\n","wordCount":"224","inLanguage":"cn","datePublished":"2020-02-01T18:39:25Z","dateModified":"2020-02-01T18:39:25Z","author":{"@type":"Person","name":"LingC"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://moonlab.top/posts/2020/android-activity-monitor/"},"publisher":{"@type":"Organization","name":"MoonLab","logo":{"@type":"ImageObject","url":"https://moonlab.top/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://moonlab.top/ accesskey=h title="MoonLab (Alt + H)"><img src=/moon.svg alt aria-label=logo height=20>MoonLab</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://moonlab.top/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://moonlab.top/archives/ title=归档><span>归档</span></a></li><li><a href=https://moonlab.top/search/ title=搜索><span>搜索</span></a></li><li><a href=https://moonlab.top/about/ title=关于><span>关于</span></a></li><li><a href=https://www.travellings.cn/go.html target=_blank title=开往><span>开往</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><div class=body-layout><div class=leftbar></div><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Android 监听第三方Activity的一举一动</h1><div class=post-meta><span title='2020-02-01 18:39:25 +0000 UTC'>February 1, 2020</span>&nbsp;·&nbsp;LingC</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#%e6%ad%a3%e6%96%87 aria-label=正文>正文</a><ul><li><a href=#%e6%96%b9%e6%b3%951 aria-label=方法1>方法1</a></li><li><a href=#%e6%96%b9%e6%b3%952- aria-label="方法2 (???)">方法2 (???)</a></li><li><a href=#%e6%96%b9%e6%b3%953 aria-label=方法3>方法3</a><ul><li><a href=#shizuku-%e5%81%9a%e6%b3%95 aria-label="Shizuku 做法">Shizuku 做法</a></li></ul></li></ul></li></ul></div></details></div><div class=post-summary><span class=bold-text>📦 由AI生成的摘要</span><br><span class=post-summary-main>这篇文章主要记录了作者在2019年初的个人感受和一些技术探索。作者回顾了过去一年的经历，感到没有太多进展，并提到冬季的天气和国内的传染病情况。尽管在家中待得久了，作者也提到了一些娱乐活动，比如观看动画和春晚，但整体上对新番的期待逐渐减弱。在技术方面，作者分享了在Android开发中监听Activity启动的需求，探讨了几种方法来获取Activity的类名。首先，作者提到使用`ActivityManager`的`getRunningTasks`方法，但由于权限限制，这种方法不可行。接着，作者提到`UsageStatsManager`只能获取应用包名，而无法获取Activity类名。最终，作者发现了`IActivityController`接口，并通过使用Shizuku工具来调用系统API，从而实现了监听Activity启动的功能。总结来说，文章结合了个人生活感受与技术探索，展示了作者在面对生活和技术挑战时的思考与解决方案。</span></div><div class=post-content><h1 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h1><p>距离上一次更新也已经是六个月前了。感觉2019年过得真不咋样，什么也没干成吧，没有什么进步。</p><p>不知不觉又是新的一年，2019是去年，2018就成了前年了。</p><p>这个冬天我们这都没怎么下过雪，积雪的话我知记得有一次，融化得还很快。</p><p>国内也出现了传染病，迄今为止有五千多人中枪了吧。现在也不让出去，亲戚也都没有拜完，现在天天在家窝。<del>（不过好处就是不用上学啦）</del>。</p><p>今年的央视春晚也没有看，bilibili还搞了拜年祭，拜年祭真的是一年比一年棒了，可惜我也没兴趣看。</p><p>最近在补魔法少女小圆，看得很慢。1月新番也没啥期待的，只有一部喜欢的：某科学电池炮T，毕竟是我的入坑番。还有一部是异度入侵，我不太喜欢目前的剧情，唯一喜欢的就只有OP了。</p><p>哦其实还有Acfun独播的达尔文游戏，也还可以~~（因为我喜欢女主的性格）~~</p><p>总结：一月新番喜欢的只有一部番和一首歌，没了。</p><p>感觉越来越没意思了，也可能是我心态的变化，现在我都一直在看以前的番，新番我已经没啥可期待的了。</p><p>这篇文章磨磨唧唧花费了三天，我已经把魔法少女小圆TV版看完了，太特喵好看了，还有剧场版和外传又够我看一阵子了。</p><p>好多人都说“致郁”，其实我觉得还可以啊并不怎么致郁，相反还有些治愈（迫真脸）。</p><hr><p>[TOC]</p><h1 id=正文>正文<a hidden class=anchor aria-hidden=true href=#正文>#</a></h1><p>回归正题，我在开发的过程中有一个小需求：需要监听每一个Activity的启动，并且需要获取Activity的ClassName。</p><p>我这种菜鸡只能先求助百度：Android 监听第三方Activity</p><h2 id=方法1>方法1<a hidden class=anchor aria-hidden=true href=#方法1>#</a></h2><p>首先百度到的第一个方法是搞一个Service，然后在一个循环里一直获取栈顶的Activity。</p><p>emmmmmm&mldr;.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>ActivityManager.<span style=color:#a6e22e>RunningTaskInfo</span><span style=color:#f92672>&gt;</span> runningTasks <span style=color:#f92672>=</span> am.<span style=color:#a6e22e>getRunningTasks</span>(1);
</span></span><span style=display:flex><span>ActivityManager.<span style=color:#a6e22e>RunningTaskInfo</span> runningTaskInfo <span style=color:#f92672>=</span> runningTasks.<span style=color:#a6e22e>get</span>(0);
</span></span></code></pre></div><p>这个办法肯定是不行哒，Google早已对getRunningTasks方法严加管制，需要<code>android.permission.GET_TOP_ACTIVITY_INFO</code>权限，但是这个权限必须要系统app才能申请。</p><p>但或许能用shell指令 ps 来获取栈顶的 Activity，虽然我没试过。</p><h2 id=方法2->方法2 (???)<a hidden class=anchor aria-hidden=true href=#方法2->#</a></h2><p>第二个方法是使用 <code>UsageStatsManager</code>，也就是应用使用情况的一个功能。</p><p>但是只能得到应用的包名，而不是Activity的类名。</p><h2 id=方法3>方法3<a hidden class=anchor aria-hidden=true href=#方法3>#</a></h2><p>在我百度的时候我注意到了一个接口：<code>IActivityController</code>和一个方法：<code>setActivityController</code>。</p><p>啊，决定了，就是你啦！</p><p>我开始了解有关IActivityController的详细内容。</p><p>我还发现了一个比AndroidXref稍微更友好的Android源码在线查看网站：https://www.androidos.net.cn/</p><p>本来<code>setActivityController</code>这个方法是在ActivityManagerNative中的，但是在Android API 26的时候似乎被遗弃了，取而代之的是IActivityManager中的<code>setActivityController</code>。</p><p>在之前，启动Activity的是ActivityManagerNative,getDefault()内的startActivity方法，而ActivityManagerService继承自ActivityManagerNative，ActivityManagerNative又继承自Binder并实现iActivityManager，AMS是IActivityManager的具体实现。</p><p><code>IInterface</code>, <code>Stub</code>, <code>Proxy</code> 三个类是分离的，分别是 IActivityManager，ActivityManagerNative (extends Binder) 和 ActivityManagerProxy。</p><p>而现在（API 26+），AMS直接继承了 IActivityManager的内部类 Stub：</p><p>这时候 Android 源码已经有了 IActivityManager.aidl，ActivityManagerNative 这个类被弃用了</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ActivityManagerService</span> <span style=color:#66d9ef>extends</span> IActivityManager.<span style=color:#a6e22e>Stub</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>implements</span> Watchdog.<span style=color:#a6e22e>Monitor</span>, BatteryStatsImpl.<span style=color:#a6e22e>BatteryCallback</span> {
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>那么自然而然，setIActivityController 这个方法是在 IActivityManager.aidl 内定义的，</p><p>而 IActivityController 是一个在 Binder 中的回调接口，可以直接下载 IActivityController.aidl 放在 android.app 这个包下。要与 Android 系统源码的位置一致。</p><p>但是该怎么调用 系统API 呢？除非我们的应用得在系统进程。</p><p>这时候我在酷安看到了一个叫做 Shizuku 的玩意：<a href=https://shizuku.rikka.app/>官方文档</a></p><p>它可以帮助我们快速使用 系统API，用户只需用 adb 或者 root 激活 Shizuku，看看官方文档的解释：</p><blockquote><h3 id=shizuku-做法>Shizuku 做法<a hidden class=anchor aria-hidden=true href=#shizuku-做法>#</a></h3><p>Shizuku app 会引导用户使用 root 或是 adb 方式运行一个进程（Shizuku 服务进程）。</p><ol><li>应用进程启动时 Shizuku 服务进程发送 binder 至应用进程</li><li>应用通过该 binder 与 Shizuku 服务进程交互，Shizuku 服务进程通过 binder 与 system server 交互</li></ol><p>Shizuku 的优点在于：</p><ol><li>极小额外时间及性能消耗</li><li>与直接调用 API 体验几乎一致（应用开发者只许添加少量代码）</li></ol></blockquote><p>导入 Shizuku 的开源库，先在 android.app 包内创建一个同名文件：!ActivityManager.java</p><p>假装他是 IActivityManager.aidl 自动生成的一个类（我们无需在下载 IActivityManager.aidl 放在项目里）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> android.app;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> android.os.Binder;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> android.os.IBinder;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> android.os.IInterface;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 我们自己创建的 IActivityManager */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IActivityManager</span> <span style=color:#66d9ef>extends</span> IInterface {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setActivityController</span>(IActivityController watcher, <span style=color:#66d9ef>boolean</span> imAMonkey);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Stub</span> <span style=color:#66d9ef>extends</span> Binder <span style=color:#66d9ef>implements</span> IActivityManager {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> IActivityManager <span style=color:#a6e22e>asInterface</span>(IBinder obj) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> UnsupportedOperationException();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>结构和 aidl 自动生成的类没什么两样，就是只把关键的方法写出来。</p><p>注意哦，这个 Stub 是一个抽象类！asInterface 方法并没有具体的实现。</p><p>之后我们再：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> IActivityManager ACTIVITY_MANAGER <span style=color:#f92672>=</span> IActivityManager.<span style=color:#a6e22e>Stub</span>.<span style=color:#a6e22e>asInterface</span>(<span style=color:#66d9ef>new</span> ShizukuBinderWrapper(SystemServiceHelper.<span style=color:#a6e22e>getSystemService</span>(<span style=color:#e6db74>&#34;activity&#34;</span>)));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setActivityController</span>(IActivityController activityController) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>ShizukuService.<span style=color:#a6e22e>pingBinder</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        ACTIVITY_MANAGER.<span style=color:#a6e22e>setActivityController</span>(activityController, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>这样我们就能直接调用 setActivityController 方法了，然后在重写 IActivityController.Stub 内的回调方法就行了。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://moonlab.top/tags/android/>Android</a></li></ul></footer><script src=https://comment.moonlab.top/moontalk.js></script><div id=container></div><script>(new MoonTalk).init({page_key:window.location.href,server:"https:///comment.moonlab.top",element:"#container"})</script></article></main><aside class=rightbar><div class=rightbar-categories><h3>分类</h3><ul class=rightbar-categories-first-list><li><a href=https://moonlab.top/categories/programming/>Programming</a> (16)<ul class=rightbar-categories-sec-list><li><a href=/tags/embeded>Embeded</a></li><li><a href=/tags/golang>golang</a></li><li><a href=/tags/linux>Linux</a></li><li><a href=/tags/android>Android</a></li></ul></li><li><a href=https://moonlab.top/categories/reverse/>Reverse</a> (1)<ul class=rightbar-categories-sec-list><li><a href=/tags/javascript>JavaScript</a></li></ul></li><li><a href=https://moonlab.top/categories/%E5%85%B6%E4%BB%96/>其他</a> (5)<ul class=rightbar-categories-sec-list><li><a href=/tags/blog>blog</a></li></ul></li><li><a href=https://moonlab.top/categories/%E7%AE%97%E6%B3%95/>算法</a> (4)<ul class=rightbar-categories-sec-list></ul></li></ul></div></aside></div><footer class=footer><img id=mooncounter-img style="margin:0 auto;margin-bottom:6px"></img>
<script src="//counter.moonlab.top/img?name=https://moonlab.top/"></script><span>&copy; 2025 <a href=https://moonlab.top/>MoonLab</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span><a href=https://www.travellings.cn/go.html rel=noopener target=_blank><img style=height:27px alt=travelling src=https://www.travellings.cn/assets/logo.svg></a></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>